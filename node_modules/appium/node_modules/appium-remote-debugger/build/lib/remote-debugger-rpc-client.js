'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bplistCreator = require('bplist-creator');

var _bplistCreator2 = _interopRequireDefault(_bplistCreator);

var _bplistParser = require('bplist-parser');

var _bplistParser2 = _interopRequireDefault(_bplistParser);

var _bufferpack = require('bufferpack');

var _bufferpack2 = _interopRequireDefault(_bufferpack);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _remoteDebugger = require('./remote-debugger');

var _uuidJs = require('uuid-js');

var _uuidJs2 = _interopRequireDefault(_uuidJs);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _remoteDebuggerMessageHandler = require('./remote-debugger-message-handler');

var _remoteDebuggerMessageHandler2 = _interopRequireDefault(_remoteDebuggerMessageHandler);

var _remoteMessages = require('./remote-messages');

var _remoteMessages2 = _interopRequireDefault(_remoteMessages);

var RemoteDebuggerRpcClient = (function () {
  function RemoteDebuggerRpcClient() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, RemoteDebuggerRpcClient);

    var _opts$host = opts.host;
    var host = _opts$host === undefined ? '::1' : _opts$host;
    var _opts$port = opts.port;
    var port = _opts$port === undefined ? _remoteDebugger.REMOTE_DEBUGGER_PORT : _opts$port;
    var socketPath = opts.socketPath;
    var _opts$specialMessageHandlers = opts.specialMessageHandlers;
    var specialMessageHandlers = _opts$specialMessageHandlers === undefined ? {} : _opts$specialMessageHandlers;
    var messageProxy = opts.messageProxy;

    // host/port config for TCP communication, socketPath for unix domain sockets
    this.host = host;
    this.port = port;
    this.socketPath = socketPath;
    this.messageProxy = messageProxy;

    this.socket = null;
    this.connected = false;
    this.connId = _uuidJs2['default'].create().toString();
    this.senderId = _uuidJs2['default'].create().toString();
    this.curMsgId = 0;
    this.received = Buffer.alloc(0);
    this.readPos = 0;

    // message handlers
    this.specialMessageHandlers = specialMessageHandlers;
    this.messageHandler = null;
  }

  _createClass(RemoteDebuggerRpcClient, [{
    key: 'connect',
    value: function connect() {
      return _regeneratorRuntime.async(function connect$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.messageHandler = new _remoteDebuggerMessageHandler2['default'](this.specialMessageHandlers);

            // create socket and handle its messages
            if (this.socketPath) {
              if (this.messageProxy) {
                // unix domain socket via proxy
                _logger2['default'].debug('Connecting to remote debugger via proxy through unix domain socket: \'' + this.messageProxy + '\'');
                this.socket = _net2['default'].connect(this.messageProxy);

                // Forward the actual socketPath to the proxy
                this.socket.once('connect', function () {
                  _logger2['default'].debug('Forwarding the actual web inspector socket to the proxy: \'' + _this.socketPath + '\'');
                  _this.socket.write(JSON.stringify({ socketPath: _this.socketPath }));
                });
              } else {
                // unix domain socket
                _logger2['default'].debug('Connecting to remote debugger through unix domain socket: \'' + this.socketPath + '\'');
                this.socket = _net2['default'].connect(this.socketPath);
              }
            } else {
              if (this.messageProxy) {
                // connect to the proxy instead of the remote debugger directly
                this.port = this.messageProxy;
              }

              // tcp socket
              _logger2['default'].debug('Connecting to remote debugger ' + (this.messageProxy ? 'via proxy ' : '') + 'through TCP: ' + this.host + ':' + this.port);
              this.socket = new _net2['default'].Socket({ type: 'tcp6' });
              this.socket.connect(this.port, this.host);
            }

            this.socket.setNoDelay(true);
            this.socket.on('close', function () {
              if (_this.connected) {
                _logger2['default'].debug('Debugger socket disconnected');
              }
              _this.connected = false;
              _this.socket = null;
            });
            this.socket.on('end', function () {
              _this.connected = false;
            });
            this.socket.on('data', this.receive.bind(this));

            // connect the socket
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
              // only resolve this function when we are actually connected
              _this.socket.on('connect', function callee$3$0() {
                return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      _logger2['default'].debug('Debugger socket connected');
                      this.connected = true;

                      resolve();

                    case 3:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this);
              });
              _this.socket.on('error', function (err) {
                if (_this.connected) {
                  _logger2['default'].error('Socket error: ' + err.message);
                  _this.connected = false;
                }

                // the connection was refused, so reject the connect promise
                reject(err);
              });
            }));

          case 8:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      return _regeneratorRuntime.async(function disconnect$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isConnected()) {
              _logger2['default'].debug('Disconnecting from remote debugger');
              this.socket.destroy();
            }
            this.connected = false;

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.connected;
    }
  }, {
    key: 'setSpecialMessageHandler',
    value: function setSpecialMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setSpecialMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'getSpecialMessageHandler',
    value: function getSpecialMessageHandler(key) {
      return this.messageHandler.getSpecialMessageHandler(key);
    }
  }, {
    key: 'setDataMessageHandler',
    value: function setDataMessageHandler(key, errorHandler, handler) {
      this.messageHandler.setDataMessageHandler(key, errorHandler, handler);
    }
  }, {
    key: 'allowNavigationWithoutReload',
    value: function allowNavigationWithoutReload() {
      var allow = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      this.messageHandler.allowNavigationWithoutReload(allow);
    }
  }, {
    key: 'selectApp',
    value: function selectApp(appIdKey, applicationConnectedHandler) {
      return _regeneratorRuntime.async(function selectApp$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(new _bluebird2['default'](function (resolve, reject) {
              // local callback, temporarily added as callback to
              // `_rpc_applicationConnected:` remote debugger response
              // to handle the initial connection
              var onAppChange = function onAppChange(dict) {
                var oldAppIdKey, correctAppIdKey;
                return _regeneratorRuntime.async(function onAppChange$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      oldAppIdKey = dict.WIRHostApplicationIdentifierKey;
                      correctAppIdKey = dict.WIRApplicationIdentifierKey;

                      // if this is a report of a proxy redirect from the remote debugger
                      // we want to update our dictionary and get a new app id
                      if (oldAppIdKey && correctAppIdKey !== oldAppIdKey) {
                        _logger2['default'].debug('We were notified we might have connected to the wrong app. ' + ('Using id ' + correctAppIdKey + ' instead of ' + oldAppIdKey));
                      }

                      applicationConnectedHandler(dict);
                      reject(new Error('New application has connected'));

                    case 5:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this2);
              };
              _this2.setSpecialMessageHandler('_rpc_applicationConnected:', reject, onAppChange);

              // do the actual connecting to the app
              return (function callee$3$0() {
                var _ref, _ref2, connectedAppIdKey, pageDict, msg;

                return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                  while (1) switch (context$4$0.prev = context$4$0.next) {
                    case 0:
                      context$4$0.next = 2;
                      return _regeneratorRuntime.awrap(this.send('connectToApp', {
                        appIdKey: appIdKey
                      }));

                    case 2:
                      _ref = context$4$0.sent;
                      _ref2 = _slicedToArray(_ref, 2);
                      connectedAppIdKey = _ref2[0];
                      pageDict = _ref2[1];

                      // sometimes the connect logic happens, but with an empty dictionary
                      // which leads to the remote debugger getting disconnected, and into a loop
                      if (_lodash2['default'].isEmpty(pageDict)) {
                        msg = 'Empty page dictionary received';

                        _logger2['default'].debug(msg);
                        reject(new Error(msg));
                      } else {
                        resolve([connectedAppIdKey, pageDict]);
                      }

                    case 7:
                    case 'end':
                      return context$4$0.stop();
                  }
                }, null, _this2);
              })();
            })['finally'](function () {
              // no matter what, we want to restore the handler that was changed.
              _this2.setSpecialMessageHandler('_rpc_applicationConnected:', null, applicationConnectedHandler);
            }));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'send',
    value: function send(command) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var onSocketError;
      return _regeneratorRuntime.async(function send$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            onSocketError = undefined;
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              // promise to be resolved whenever remote debugger
              // replies to our request

              // retrieve the correct command to send
              opts = _lodash2['default'].defaults({ connId: _this3.connId, senderId: _this3.senderId }, opts);
              var data = (0, _remoteMessages2['default'])(command, opts);

              // most of the time we don't care when socket.write does
              // so give it an empty function
              var socketCb = _lodash2['default'].noop;

              // handle socket problems
              onSocketError = function (exception) {
                if (_this3.connected) {
                  _logger2['default'].error('Socket error: ' + exception.message);
                }

                // the connection was refused, so reject the connect promise
                reject(exception);
              };
              _this3.socket.on('error', onSocketError);
              if (_this3.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                (function () {
                  // special replies will return any number of arguments
                  // temporarily wrap with promise handling
                  var specialMessageHandler = _this3.getSpecialMessageHandler(data.__selector);
                  _this3.setSpecialMessageHandler(data.__selector, reject, (function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }

                    _logger2['default'].debug('Received response from socket send: \'' + _lodash2['default'].truncate(JSON.stringify(args), { length: 50 }) + '\'');

                    // call the original listener, and put it back, if necessary
                    specialMessageHandler.apply(undefined, args);
                    if (this.messageHandler.hasSpecialMessageHandler(data.__selector)) {
                      // this means that the system has not removed this listener
                      this.setSpecialMessageHandler(data.__selector, null, specialMessageHandler);
                    }

                    resolve(args);
                  }).bind(_this3));
                })();
              } else if (data.__argument && data.__argument.WIRSocketDataKey) {
                // keep track of the messages coming and going using
                // a simple sequential id
                _this3.curMsgId++;

                var errorHandler = function errorHandler(err) {
                  var msg = 'Remote debugger error with code \'' + err.code + '\': ' + err.message;
                  reject(new Error(msg));
                };

                _this3.setDataMessageHandler(_this3.curMsgId.toString(), errorHandler, function (value) {
                  var msg = _lodash2['default'].truncate(_lodash2['default'].isString(value) ? value : JSON.stringify(value), { length: 50 });
                  _logger2['default'].debug('Received data response from socket send: \'' + msg + '\'');
                  _logger2['default'].debug('Original command: ' + command);
                  resolve(value);
                });
                data.__argument.WIRSocketDataKey.id = _this3.curMsgId;
                data.__argument.WIRSocketDataKey = Buffer.from(JSON.stringify(data.__argument.WIRSocketDataKey));
              } else {
                // we want to immediately resolve this socket.write
                // any long term callbacks will do their business in the background
                socketCb = resolve;
              }

              _logger2['default'].debug('Sending \'' + data.__selector + '\' message to remote debugger');

              // remote debugger expects a binary plist as data
              var plist = undefined;
              try {
                plist = (0, _bplistCreator2['default'])(data);
              } catch (e) {
                var msg = 'Could not create binary plist from data: ' + e.message;
                _logger2['default'].error(msg);
                return reject(new Error(msg));
              }

              if (_this3.socket && _this3.connected) {
                // cork and uncork in order to not buffer the write
                // on some systems this is necessary or the server
                // gets confused.
                _this3.socket.cork();
                try {
                  _this3.socket.write(_bufferpack2['default'].pack('L', [plist.length]));
                  _this3.socket.write(plist, socketCb);
                } finally {
                  // https://nodejs.org/api/stream.html#stream_writable_uncork
                  process.nextTick(function () {
                    return _this3.socket.uncork();
                  });
                }
              } else {
                var msg = 'Attempted to write data to socket after it was closed!';
                _logger2['default'].error(msg);
                reject(new Error(msg));
              }
            })['finally'](function () {
              // remove this listener, so we don't exhaust the system
              _this3.socket.removeListener('error', onSocketError);
            }));

          case 2:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'receive',
    value: function receive(data) {
      // Append this new data to the existing Buffer
      this.received = Buffer.concat([this.received, data]);
      var dataLeftOver = true;

      // Parse multiple messages in the same packet
      while (dataLeftOver) {
        // Store a reference to where we were
        var oldReadPos = this.readPos;

        // Read the prefix (plist length) to see how far to read next
        // It's always 4 bytes long
        var prefix = this.received.slice(this.readPos, this.readPos + 4);

        var msgLength = undefined;
        try {
          msgLength = _bufferpack2['default'].unpack('L', prefix)[0];
        } catch (e) {
          _logger2['default'].error('Buffer could not unpack: ' + e);
          return;
        }

        // Jump forward 4 bytes
        this.readPos += 4;

        // Is there enough data here?
        // If not, jump back to our original position and gtfo
        if (this.received.length < msgLength + this.readPos) {
          this.readPos = oldReadPos;
          break;
        }

        // Extract the main body of the message (where the plist should be)
        var body = this.received.slice(this.readPos, msgLength + this.readPos);

        // Extract the plist
        var plist = undefined;
        try {
          plist = _bplistParser2['default'].parseBuffer(body);
        } catch (e) {
          _logger2['default'].error('Error parsing binary plist: ' + e);
          return;
        }

        // bplistParse.parseBuffer returns an array
        if (plist.length === 1) {
          plist = plist[0];
        }

        var _arr = ['WIRMessageDataKey', 'WIRDestinationKey', 'WIRSocketDataKey'];
        for (var _i = 0; _i < _arr.length; _i++) {
          var key = _arr[_i];
          if (!_lodash2['default'].isUndefined(plist[key])) {
            plist[key] = plist[key].toString("utf8");
          }
        }

        // Jump forward the length of the plist
        this.readPos += msgLength;

        // Calculate how much buffer is left
        var leftOver = this.received.length - this.readPos;

        // Is there some left over?
        if (leftOver !== 0) {
          // Copy what's left over into a new buffer, and save it for next time
          var chunk = Buffer.alloc(leftOver);
          this.received.copy(chunk, 0, this.readPos);
          this.received = chunk;
        } else {
          // Otherwise, empty the buffer and get out of the loop
          this.received = Buffer.alloc(0);
          dataLeftOver = false;
        }

        // Reset the read position
        this.readPos = 0;

        // Now do something with the plist
        if (plist) {
          this.messageHandler.handleMessage(plist);
        }
      }
    }
  }, {
    key: 'setTimelineEventHandler',
    value: function setTimelineEventHandler(timelineEventHandler) {
      this.timelineEventHandler = timelineEventHandler;
      this.messageHandler.setTimelineEventHandler(timelineEventHandler);
    }
  }, {
    key: 'setConsoleLogEventHandler',
    value: function setConsoleLogEventHandler(consoleEventHandler) {
      this.consoleEventHandler = consoleEventHandler;
      this.messageHandler.setConsoleLogEventHandler(consoleEventHandler);
    }
  }, {
    key: 'setNetworkLogEventHandler',
    value: function setNetworkLogEventHandler(networkEventHandler) {
      this.networkEventHandler = networkEventHandler;
      this.messageHandler.setNetworkEventHandler(networkEventHandler);
    }
  }]);

  return RemoteDebuggerRpcClient;
})();

exports['default'] = RemoteDebuggerRpcClient;
module.exports = exports['default'];

// from the dictionary returned, get the ids

// error listener, which needs to be removed after the promise is resolved
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9yZW1vdGUtZGVidWdnZXItcnBjLWNsaWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O3NCQUFnQixVQUFVOzs7O3NCQUNaLFFBQVE7Ozs7NkJBQ0csZ0JBQWdCOzs7OzRCQUNqQixlQUFlOzs7OzBCQUNoQixZQUFZOzs7O3dCQUNmLFVBQVU7Ozs7OEJBQ08sbUJBQW1COztzQkFDdkMsU0FBUzs7OzttQkFDVixLQUFLOzs7OzRDQUNTLG1DQUFtQzs7Ozs4QkFDcEMsbUJBQW1COzs7O0lBRzNCLHVCQUF1QjtBQUM5QixXQURPLHVCQUF1QixHQUNsQjtRQUFYLElBQUkseURBQUcsRUFBRTs7MEJBREgsdUJBQXVCOztxQkFRcEMsSUFBSSxDQUxOLElBQUk7UUFBSixJQUFJLDhCQUFHLEtBQUs7cUJBS1YsSUFBSSxDQUpOLElBQUk7UUFBSixJQUFJO1FBQ0osVUFBVSxHQUdSLElBQUksQ0FITixVQUFVO3VDQUdSLElBQUksQ0FGTixzQkFBc0I7UUFBdEIsc0JBQXNCLGdEQUFHLEVBQUU7UUFDM0IsWUFBWSxHQUNWLElBQUksQ0FETixZQUFZOzs7QUFJZCxRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixRQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztBQUM3QixRQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQzs7QUFFakMsUUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDbkIsUUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdkIsUUFBSSxDQUFDLE1BQU0sR0FBRyxvQkFBSyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUN2QyxRQUFJLENBQUMsUUFBUSxHQUFHLG9CQUFLLE1BQU0sRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3pDLFFBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FB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QyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDM0MsY0FBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7U0FDdkIsTUFBTTs7QUFFTCxjQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEMsc0JBQVksR0FBRyxLQUFLLENBQUM7U0FDdEI7OztBQUdELFlBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDOzs7QUFHakIsWUFBSSxLQUFLLEVBQUU7QUFDVCxjQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMxQztPQUNGO0tBQ0Y7OztXQUV1QixpQ0FBQyxvQkFBb0IsRUFBRTtBQUM3QyxVQUFJLENBQUMsb0JBQW9CLEdBQUcsb0JBQW9CLENBQUM7QUFDakQsVUFBSSxDQUFDLGNBQWMsQ0FBQyx1QkFBdUIsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0tBQ25FOzs7V0FFeUIsbUNBQUMsbUJBQW1CLEVBQUU7QUFDOUMsVUFBSSxDQUFDLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDO0FBQy9DLFVBQUksQ0FBQyxjQUFjLENBQUMseUJBQXlCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztLQUNwRTs7O1dBRXlCLG1DQUFDLG1CQUFtQixFQUFFO0FBQzlDLFVBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztBQUMvQyxVQUFJLENBQUMsY0FBYyxDQUFDLHNCQUFzQixDQUFDLG1CQUFtQixDQUFDLENBQUM7S0FDakU7OztTQS9Xa0IsdUJBQXVCOzs7cUJBQXZCLHVCQUF1QiIsImZpbGUiOiJsaWIvcmVtb3RlLWRlYnVnZ2VyLXJwYy1jbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgYnBsaXN0Q3JlYXRlIGZyb20gJ2JwbGlzdC1jcmVhdG9yJztcbmltcG9ydCBicGxpc3RQYXJzZSBmcm9tICdicGxpc3QtcGFyc2VyJztcbmltcG9ydCBidWZmZXJwYWNrIGZyb20gJ2J1ZmZlcnBhY2snO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgUkVNT1RFX0RFQlVHR0VSX1BPUlQgfSBmcm9tICcuL3JlbW90ZS1kZWJ1Z2dlcic7XG5pbXBvcnQgVVVJRCBmcm9tICd1dWlkLWpzJztcbmltcG9ydCBuZXQgZnJvbSAnbmV0JztcbmltcG9ydCBScGNNZXNzYWdlSGFuZGxlciBmcm9tICcuL3JlbW90ZS1kZWJ1Z2dlci1tZXNzYWdlLWhhbmRsZXInO1xuaW1wb3J0IGdldFJlbW90ZUNvbW1hbmQgZnJvbSAnLi9yZW1vdGUtbWVzc2FnZXMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZURlYnVnZ2VyUnBjQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhvc3QgPSAnOjoxJyxcbiAgICAgIHBvcnQgPSBSRU1PVEVfREVCVUdHRVJfUE9SVCxcbiAgICAgIHNvY2tldFBhdGgsXG4gICAgICBzcGVjaWFsTWVzc2FnZUhhbmRsZXJzID0ge30sXG4gICAgICBtZXNzYWdlUHJveHksXG4gICAgfSA9IG9wdHM7XG5cbiAgICAvLyBob3N0L3BvcnQgY29uZmlnIGZvciBUQ1AgY29tbXVuaWNhdGlvbiwgc29ja2V0UGF0aCBmb3IgdW5peCBkb21haW4gc29ja2V0c1xuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICB0aGlzLnNvY2tldFBhdGggPSBzb2NrZXRQYXRoO1xuICAgIHRoaXMubWVzc2FnZVByb3h5ID0gbWVzc2FnZVByb3h5O1xuXG4gICAgdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25uSWQgPSBVVUlELmNyZWF0ZSgpLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5zZW5kZXJJZCA9IFVVSUQuY3JlYXRlKCkudG9TdHJpbmcoKTtcbiAgICB0aGlzLmN1ck1zZ0lkID0gMDtcbiAgICB0aGlzLnJlY2VpdmVkID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHRoaXMucmVhZFBvcyA9IDA7XG5cbiAgICAvLyBtZXNzYWdlIGhhbmRsZXJzXG4gICAgdGhpcy5zcGVjaWFsTWVzc2FnZUhhbmRsZXJzID0gc3BlY2lhbE1lc3NhZ2VIYW5kbGVycztcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3QgKCkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBuZXcgUnBjTWVzc2FnZUhhbmRsZXIodGhpcy5zcGVjaWFsTWVzc2FnZUhhbmRsZXJzKTtcblxuICAgIC8vIGNyZWF0ZSBzb2NrZXQgYW5kIGhhbmRsZSBpdHMgbWVzc2FnZXNcbiAgICBpZiAodGhpcy5zb2NrZXRQYXRoKSB7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlUHJveHkpIHtcbiAgICAgICAgLy8gdW5peCBkb21haW4gc29ja2V0IHZpYSBwcm94eVxuICAgICAgICBsb2cuZGVidWcoYENvbm5lY3RpbmcgdG8gcmVtb3RlIGRlYnVnZ2VyIHZpYSBwcm94eSB0aHJvdWdoIHVuaXggZG9tYWluIHNvY2tldDogJyR7dGhpcy5tZXNzYWdlUHJveHl9J2ApO1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldC5jb25uZWN0KHRoaXMubWVzc2FnZVByb3h5KTtcblxuICAgICAgICAvLyBGb3J3YXJkIHRoZSBhY3R1YWwgc29ja2V0UGF0aCB0byB0aGUgcHJveHlcbiAgICAgICAgdGhpcy5zb2NrZXQub25jZSgnY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICBsb2cuZGVidWcoYEZvcndhcmRpbmcgdGhlIGFjdHVhbCB3ZWIgaW5zcGVjdG9yIHNvY2tldCB0byB0aGUgcHJveHk6ICcke3RoaXMuc29ja2V0UGF0aH0nYCk7XG4gICAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoSlNPTi5zdHJpbmdpZnkoe3NvY2tldFBhdGg6IHRoaXMuc29ja2V0UGF0aH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVuaXggZG9tYWluIHNvY2tldFxuICAgICAgICBsb2cuZGVidWcoYENvbm5lY3RpbmcgdG8gcmVtb3RlIGRlYnVnZ2VyIHRocm91Z2ggdW5peCBkb21haW4gc29ja2V0OiAnJHt0aGlzLnNvY2tldFBhdGh9J2ApO1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldC5jb25uZWN0KHRoaXMuc29ja2V0UGF0aCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VQcm94eSkge1xuICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSBwcm94eSBpbnN0ZWFkIG9mIHRoZSByZW1vdGUgZGVidWdnZXIgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5wb3J0ID0gdGhpcy5tZXNzYWdlUHJveHk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRjcCBzb2NrZXRcbiAgICAgIGxvZy5kZWJ1ZyhgQ29ubmVjdGluZyB0byByZW1vdGUgZGVidWdnZXIgJHt0aGlzLm1lc3NhZ2VQcm94eSA/ICd2aWEgcHJveHkgJyA6ICcnfXRocm91Z2ggVENQOiAke3RoaXMuaG9zdH06JHt0aGlzLnBvcnR9YCk7XG4gICAgICB0aGlzLnNvY2tldCA9IG5ldyBuZXQuU29ja2V0KHt0eXBlOiAndGNwNid9KTtcbiAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QodGhpcy5wb3J0LCB0aGlzLmhvc3QpO1xuICAgIH1cblxuICAgIHRoaXMuc29ja2V0LnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIGxvZy5kZWJ1ZygnRGVidWdnZXIgc29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5vbignZGF0YScsIHRoaXMucmVjZWl2ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIGNvbm5lY3QgdGhlIHNvY2tldFxuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBvbmx5IHJlc29sdmUgdGhpcyBmdW5jdGlvbiB3aGVuIHdlIGFyZSBhY3R1YWxseSBjb25uZWN0ZWRcbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBsb2cuZGVidWcoYERlYnVnZ2VyIHNvY2tldCBjb25uZWN0ZWRgKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zb2NrZXQub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoYFNvY2tldCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGNvbm5lY3Rpb24gd2FzIHJlZnVzZWQsIHNvIHJlamVjdCB0aGUgY29ubmVjdCBwcm9taXNlXG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBkaXNjb25uZWN0ICgpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICBsb2cuZGVidWcoJ0Rpc2Nvbm5lY3RpbmcgZnJvbSByZW1vdGUgZGVidWdnZXInKTtcbiAgICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlzQ29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWQ7XG4gIH1cblxuICBzZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIgKGtleSwgZXJyb3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoa2V5LCBlcnJvckhhbmRsZXIsIGhhbmRsZXIpO1xuICB9XG5cbiAgZ2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5nZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoa2V5KTtcbiAgfVxuXG4gIHNldERhdGFNZXNzYWdlSGFuZGxlciAoa2V5LCBlcnJvckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldERhdGFNZXNzYWdlSGFuZGxlcihrZXksIGVycm9ySGFuZGxlciwgaGFuZGxlcik7XG4gIH1cblxuICBhbGxvd05hdmlnYXRpb25XaXRob3V0UmVsb2FkIChhbGxvdyA9IHRydWUpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmFsbG93TmF2aWdhdGlvbldpdGhvdXRSZWxvYWQoYWxsb3cpO1xuICB9XG5cbiAgYXN5bmMgc2VsZWN0QXBwIChhcHBJZEtleSwgYXBwbGljYXRpb25Db25uZWN0ZWRIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIGxvY2FsIGNhbGxiYWNrLCB0ZW1wb3JhcmlseSBhZGRlZCBhcyBjYWxsYmFjayB0b1xuICAgICAgLy8gYF9ycGNfYXBwbGljYXRpb25Db25uZWN0ZWQ6YCByZW1vdGUgZGVidWdnZXIgcmVzcG9uc2VcbiAgICAgIC8vIHRvIGhhbmRsZSB0aGUgaW5pdGlhbCBjb25uZWN0aW9uXG4gICAgICBsZXQgb25BcHBDaGFuZ2UgPSBhc3luYyAoZGljdCkgPT4ge1xuICAgICAgICAvLyBmcm9tIHRoZSBkaWN0aW9uYXJ5IHJldHVybmVkLCBnZXQgdGhlIGlkc1xuICAgICAgICBsZXQgb2xkQXBwSWRLZXkgPSBkaWN0LldJUkhvc3RBcHBsaWNhdGlvbklkZW50aWZpZXJLZXk7XG4gICAgICAgIGxldCBjb3JyZWN0QXBwSWRLZXkgPSBkaWN0LldJUkFwcGxpY2F0aW9uSWRlbnRpZmllcktleTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcmVwb3J0IG9mIGEgcHJveHkgcmVkaXJlY3QgZnJvbSB0aGUgcmVtb3RlIGRlYnVnZ2VyXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gdXBkYXRlIG91ciBkaWN0aW9uYXJ5IGFuZCBnZXQgYSBuZXcgYXBwIGlkXG4gICAgICAgIGlmIChvbGRBcHBJZEtleSAmJiBjb3JyZWN0QXBwSWRLZXkgIT09IG9sZEFwcElkS2V5KSB7XG4gICAgICAgICAgbG9nLmRlYnVnKGBXZSB3ZXJlIG5vdGlmaWVkIHdlIG1pZ2h0IGhhdmUgY29ubmVjdGVkIHRvIHRoZSB3cm9uZyBhcHAuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgVXNpbmcgaWQgJHtjb3JyZWN0QXBwSWRLZXl9IGluc3RlYWQgb2YgJHtvbGRBcHBJZEtleX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGxpY2F0aW9uQ29ubmVjdGVkSGFuZGxlcihkaWN0KTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTmV3IGFwcGxpY2F0aW9uIGhhcyBjb25uZWN0ZWQnKSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoJ19ycGNfYXBwbGljYXRpb25Db25uZWN0ZWQ6JywgcmVqZWN0LCBvbkFwcENoYW5nZSk7XG5cbiAgICAgIC8vIGRvIHRoZSBhY3R1YWwgY29ubmVjdGluZyB0byB0aGUgYXBwXG4gICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IFtjb25uZWN0ZWRBcHBJZEtleSwgcGFnZURpY3RdID0gYXdhaXQgdGhpcy5zZW5kKCdjb25uZWN0VG9BcHAnLCB7XG4gICAgICAgICAgYXBwSWRLZXlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc29tZXRpbWVzIHRoZSBjb25uZWN0IGxvZ2ljIGhhcHBlbnMsIGJ1dCB3aXRoIGFuIGVtcHR5IGRpY3Rpb25hcnlcbiAgICAgICAgLy8gd2hpY2ggbGVhZHMgdG8gdGhlIHJlbW90ZSBkZWJ1Z2dlciBnZXR0aW5nIGRpc2Nvbm5lY3RlZCwgYW5kIGludG8gYSBsb29wXG4gICAgICAgIGlmIChfLmlzRW1wdHkocGFnZURpY3QpKSB7XG4gICAgICAgICAgbGV0IG1zZyA9ICdFbXB0eSBwYWdlIGRpY3Rpb25hcnkgcmVjZWl2ZWQnO1xuICAgICAgICAgIGxvZy5kZWJ1Zyhtc2cpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShbY29ubmVjdGVkQXBwSWRLZXksIHBhZ2VEaWN0XSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAvLyBubyBtYXR0ZXIgd2hhdCwgd2Ugd2FudCB0byByZXN0b3JlIHRoZSBoYW5kbGVyIHRoYXQgd2FzIGNoYW5nZWQuXG4gICAgICB0aGlzLnNldFNwZWNpYWxNZXNzYWdlSGFuZGxlcignX3JwY19hcHBsaWNhdGlvbkNvbm5lY3RlZDonLCBudWxsLCBhcHBsaWNhdGlvbkNvbm5lY3RlZEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgc2VuZCAoY29tbWFuZCwgb3B0cyA9IHt9KSB7XG4gICAgLy8gZXJyb3IgbGlzdGVuZXIsIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICBsZXQgb25Tb2NrZXRFcnJvcjtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBwcm9taXNlIHRvIGJlIHJlc29sdmVkIHdoZW5ldmVyIHJlbW90ZSBkZWJ1Z2dlclxuICAgICAgLy8gcmVwbGllcyB0byBvdXIgcmVxdWVzdFxuXG4gICAgICAvLyByZXRyaWV2ZSB0aGUgY29ycmVjdCBjb21tYW5kIHRvIHNlbmRcbiAgICAgIG9wdHMgPSBfLmRlZmF1bHRzKHtjb25uSWQ6IHRoaXMuY29ubklkLCBzZW5kZXJJZDogdGhpcy5zZW5kZXJJZH0sIG9wdHMpO1xuICAgICAgbGV0IGRhdGEgPSBnZXRSZW1vdGVDb21tYW5kKGNvbW1hbmQsIG9wdHMpO1xuXG4gICAgICAvLyBtb3N0IG9mIHRoZSB0aW1lIHdlIGRvbid0IGNhcmUgd2hlbiBzb2NrZXQud3JpdGUgZG9lc1xuICAgICAgLy8gc28gZ2l2ZSBpdCBhbiBlbXB0eSBmdW5jdGlvblxuICAgICAgbGV0IHNvY2tldENiID0gXy5ub29wO1xuXG4gICAgICAvLyBoYW5kbGUgc29ja2V0IHByb2JsZW1zXG4gICAgICBvblNvY2tldEVycm9yID0gKGV4Y2VwdGlvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoYFNvY2tldCBlcnJvcjogJHtleGNlcHRpb24ubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIHdhcyByZWZ1c2VkLCBzbyByZWplY3QgdGhlIGNvbm5lY3QgcHJvbWlzZVxuICAgICAgICByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCBvblNvY2tldEVycm9yKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhc1NwZWNpYWxNZXNzYWdlSGFuZGxlcihkYXRhLl9fc2VsZWN0b3IpKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgcmVwbGllcyB3aWxsIHJldHVybiBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAgICAgICAvLyB0ZW1wb3JhcmlseSB3cmFwIHdpdGggcHJvbWlzZSBoYW5kbGluZ1xuICAgICAgICBsZXQgc3BlY2lhbE1lc3NhZ2VIYW5kbGVyID0gdGhpcy5nZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5zZXRTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yLCByZWplY3QsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgbG9nLmRlYnVnKGBSZWNlaXZlZCByZXNwb25zZSBmcm9tIHNvY2tldCBzZW5kOiAnJHtfLnRydW5jYXRlKEpTT04uc3RyaW5naWZ5KGFyZ3MpLCB7bGVuZ3RoOiA1MH0pfSdgKTtcblxuICAgICAgICAgIC8vIGNhbGwgdGhlIG9yaWdpbmFsIGxpc3RlbmVyLCBhbmQgcHV0IGl0IGJhY2ssIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIHNwZWNpYWxNZXNzYWdlSGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlci5oYXNTcGVjaWFsTWVzc2FnZUhhbmRsZXIoZGF0YS5fX3NlbGVjdG9yKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSBzeXN0ZW0gaGFzIG5vdCByZW1vdmVkIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHRoaXMuc2V0U3BlY2lhbE1lc3NhZ2VIYW5kbGVyKGRhdGEuX19zZWxlY3RvciwgbnVsbCwgc3BlY2lhbE1lc3NhZ2VIYW5kbGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLl9fYXJndW1lbnQgJiYgZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkpIHtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbWVzc2FnZXMgY29taW5nIGFuZCBnb2luZyB1c2luZ1xuICAgICAgICAvLyBhIHNpbXBsZSBzZXF1ZW50aWFsIGlkXG4gICAgICAgIHRoaXMuY3VyTXNnSWQrKztcblxuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYFJlbW90ZSBkZWJ1Z2dlciBlcnJvciB3aXRoIGNvZGUgJyR7ZXJyLmNvZGV9JzogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXREYXRhTWVzc2FnZUhhbmRsZXIodGhpcy5jdXJNc2dJZC50b1N0cmluZygpLCBlcnJvckhhbmRsZXIsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IF8udHJ1bmNhdGUoXy5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSwge2xlbmd0aDogNTB9KTtcbiAgICAgICAgICBsb2cuZGVidWcoYFJlY2VpdmVkIGRhdGEgcmVzcG9uc2UgZnJvbSBzb2NrZXQgc2VuZDogJyR7bXNnfSdgKTtcbiAgICAgICAgICBsb2cuZGVidWcoYE9yaWdpbmFsIGNvbW1hbmQ6ICR7Y29tbWFuZH1gKTtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGEuX19hcmd1bWVudC5XSVJTb2NrZXREYXRhS2V5LmlkID0gdGhpcy5jdXJNc2dJZDtcbiAgICAgICAgZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkgPVxuICAgICAgICAgICAgQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZGF0YS5fX2FyZ3VtZW50LldJUlNvY2tldERhdGFLZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGlzIHNvY2tldC53cml0ZVxuICAgICAgICAvLyBhbnkgbG9uZyB0ZXJtIGNhbGxiYWNrcyB3aWxsIGRvIHRoZWlyIGJ1c2luZXNzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgIHNvY2tldENiID0gcmVzb2x2ZTtcbiAgICAgIH1cblxuICAgICAgbG9nLmRlYnVnKGBTZW5kaW5nICcke2RhdGEuX19zZWxlY3Rvcn0nIG1lc3NhZ2UgdG8gcmVtb3RlIGRlYnVnZ2VyYCk7XG5cbiAgICAgIC8vIHJlbW90ZSBkZWJ1Z2dlciBleHBlY3RzIGEgYmluYXJ5IHBsaXN0IGFzIGRhdGFcbiAgICAgIGxldCBwbGlzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBsaXN0ID0gYnBsaXN0Q3JlYXRlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbXNnID0gYENvdWxkIG5vdCBjcmVhdGUgYmluYXJ5IHBsaXN0IGZyb20gZGF0YTogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb2NrZXQgJiYgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgLy8gY29yayBhbmQgdW5jb3JrIGluIG9yZGVyIHRvIG5vdCBidWZmZXIgdGhlIHdyaXRlXG4gICAgICAgIC8vIG9uIHNvbWUgc3lzdGVtcyB0aGlzIGlzIG5lY2Vzc2FyeSBvciB0aGUgc2VydmVyXG4gICAgICAgIC8vIGdldHMgY29uZnVzZWQuXG4gICAgICAgIHRoaXMuc29ja2V0LmNvcmsoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnNvY2tldC53cml0ZShidWZmZXJwYWNrLnBhY2soJ0wnLCBbcGxpc3QubGVuZ3RoXSkpO1xuICAgICAgICAgIHRoaXMuc29ja2V0LndyaXRlKHBsaXN0LCBzb2NrZXRDYik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fd3JpdGFibGVfdW5jb3JrXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB0aGlzLnNvY2tldC51bmNvcmsoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBtc2cgPSAnQXR0ZW1wdGVkIHRvIHdyaXRlIGRhdGEgdG8gc29ja2V0IGFmdGVyIGl0IHdhcyBjbG9zZWQhJztcbiAgICAgICAgbG9nLmVycm9yKG1zZyk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgdGhpcyBsaXN0ZW5lciwgc28gd2UgZG9uJ3QgZXhoYXVzdCB0aGUgc3lzdGVtXG4gICAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvblNvY2tldEVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlY2VpdmUgKGRhdGEpIHtcbiAgICAvLyBBcHBlbmQgdGhpcyBuZXcgZGF0YSB0byB0aGUgZXhpc3RpbmcgQnVmZmVyXG4gICAgdGhpcy5yZWNlaXZlZCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVjZWl2ZWQsIGRhdGFdKTtcbiAgICBsZXQgZGF0YUxlZnRPdmVyID0gdHJ1ZTtcblxuICAgIC8vIFBhcnNlIG11bHRpcGxlIG1lc3NhZ2VzIGluIHRoZSBzYW1lIHBhY2tldFxuICAgIHdoaWxlIChkYXRhTGVmdE92ZXIpIHtcbiAgICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHdoZXJlIHdlIHdlcmVcbiAgICAgIGxldCBvbGRSZWFkUG9zID0gdGhpcy5yZWFkUG9zO1xuXG4gICAgICAvLyBSZWFkIHRoZSBwcmVmaXggKHBsaXN0IGxlbmd0aCkgdG8gc2VlIGhvdyBmYXIgdG8gcmVhZCBuZXh0XG4gICAgICAvLyBJdCdzIGFsd2F5cyA0IGJ5dGVzIGxvbmdcbiAgICAgIGxldCBwcmVmaXggPSB0aGlzLnJlY2VpdmVkLnNsaWNlKHRoaXMucmVhZFBvcywgdGhpcy5yZWFkUG9zICsgNCk7XG5cbiAgICAgIGxldCBtc2dMZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICBtc2dMZW5ndGggPSBidWZmZXJwYWNrLnVucGFjaygnTCcsIHByZWZpeClbMF07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihgQnVmZmVyIGNvdWxkIG5vdCB1bnBhY2s6ICR7ZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBKdW1wIGZvcndhcmQgNCBieXRlc1xuICAgICAgdGhpcy5yZWFkUG9zICs9IDQ7XG5cbiAgICAgIC8vIElzIHRoZXJlIGVub3VnaCBkYXRhIGhlcmU/XG4gICAgICAvLyBJZiBub3QsIGp1bXAgYmFjayB0byBvdXIgb3JpZ2luYWwgcG9zaXRpb24gYW5kIGd0Zm9cbiAgICAgIGlmICh0aGlzLnJlY2VpdmVkLmxlbmd0aCA8IG1zZ0xlbmd0aCArIHRoaXMucmVhZFBvcykge1xuICAgICAgICB0aGlzLnJlYWRQb3MgPSBvbGRSZWFkUG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCB0aGUgbWFpbiBib2R5IG9mIHRoZSBtZXNzYWdlICh3aGVyZSB0aGUgcGxpc3Qgc2hvdWxkIGJlKVxuICAgICAgbGV0IGJvZHkgPSB0aGlzLnJlY2VpdmVkLnNsaWNlKHRoaXMucmVhZFBvcywgbXNnTGVuZ3RoICsgdGhpcy5yZWFkUG9zKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcGxpc3RcbiAgICAgIGxldCBwbGlzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBsaXN0ID0gYnBsaXN0UGFyc2UucGFyc2VCdWZmZXIoYm9keSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihgRXJyb3IgcGFyc2luZyBiaW5hcnkgcGxpc3Q6ICR7ZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBicGxpc3RQYXJzZS5wYXJzZUJ1ZmZlciByZXR1cm5zIGFuIGFycmF5XG4gICAgICBpZiAocGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBsaXN0ID0gcGxpc3RbMF07XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGtleSBvZiBbJ1dJUk1lc3NhZ2VEYXRhS2V5JywgJ1dJUkRlc3RpbmF0aW9uS2V5JywgJ1dJUlNvY2tldERhdGFLZXknXSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGxpc3Rba2V5XSkpIHtcbiAgICAgICAgICBwbGlzdFtrZXldID0gcGxpc3Rba2V5XS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSnVtcCBmb3J3YXJkIHRoZSBsZW5ndGggb2YgdGhlIHBsaXN0XG4gICAgICB0aGlzLnJlYWRQb3MgKz0gbXNnTGVuZ3RoO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaG93IG11Y2ggYnVmZmVyIGlzIGxlZnRcbiAgICAgIGxldCBsZWZ0T3ZlciA9IHRoaXMucmVjZWl2ZWQubGVuZ3RoIC0gdGhpcy5yZWFkUG9zO1xuXG4gICAgICAvLyBJcyB0aGVyZSBzb21lIGxlZnQgb3Zlcj9cbiAgICAgIGlmIChsZWZ0T3ZlciAhPT0gMCkge1xuICAgICAgICAvLyBDb3B5IHdoYXQncyBsZWZ0IG92ZXIgaW50byBhIG5ldyBidWZmZXIsIGFuZCBzYXZlIGl0IGZvciBuZXh0IHRpbWVcbiAgICAgICAgbGV0IGNodW5rID0gQnVmZmVyLmFsbG9jKGxlZnRPdmVyKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlZC5jb3B5KGNodW5rLCAwLCB0aGlzLnJlYWRQb3MpO1xuICAgICAgICB0aGlzLnJlY2VpdmVkID0gY2h1bms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGVtcHR5IHRoZSBidWZmZXIgYW5kIGdldCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgZGF0YUxlZnRPdmVyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSByZWFkIHBvc2l0aW9uXG4gICAgICB0aGlzLnJlYWRQb3MgPSAwO1xuXG4gICAgICAvLyBOb3cgZG8gc29tZXRoaW5nIHdpdGggdGhlIHBsaXN0XG4gICAgICBpZiAocGxpc3QpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlci5oYW5kbGVNZXNzYWdlKHBsaXN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRUaW1lbGluZUV2ZW50SGFuZGxlciAodGltZWxpbmVFdmVudEhhbmRsZXIpIHtcbiAgICB0aGlzLnRpbWVsaW5lRXZlbnRIYW5kbGVyID0gdGltZWxpbmVFdmVudEhhbmRsZXI7XG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlci5zZXRUaW1lbGluZUV2ZW50SGFuZGxlcih0aW1lbGluZUV2ZW50SGFuZGxlcik7XG4gIH1cblxuICBzZXRDb25zb2xlTG9nRXZlbnRIYW5kbGVyIChjb25zb2xlRXZlbnRIYW5kbGVyKSB7XG4gICAgdGhpcy5jb25zb2xlRXZlbnRIYW5kbGVyID0gY29uc29sZUV2ZW50SGFuZGxlcjtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldENvbnNvbGVMb2dFdmVudEhhbmRsZXIoY29uc29sZUV2ZW50SGFuZGxlcik7XG4gIH1cblxuICBzZXROZXR3b3JrTG9nRXZlbnRIYW5kbGVyIChuZXR3b3JrRXZlbnRIYW5kbGVyKSB7XG4gICAgdGhpcy5uZXR3b3JrRXZlbnRIYW5kbGVyID0gbmV0d29ya0V2ZW50SGFuZGxlcjtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNldE5ldHdvcmtFdmVudEhhbmRsZXIobmV0d29ya0V2ZW50SGFuZGxlcik7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
