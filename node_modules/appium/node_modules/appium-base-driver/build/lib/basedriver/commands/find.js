'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _ = require('../../..');

var _images = require('./images');

var _protocolProtocol = require('../../protocol/protocol');

var _imageElement = require('../image-element');

var _appiumSupport = require('appium-support');

var commands = {},
    helpers = {},
    extensions = {};

var IMAGE_STRATEGY = "-image";

// Override the following function for your own driver, and the rest is taken
// care of!

//helpers.findElOrEls = async function (strategy, selector, mult, context) {}
// strategy: locator strategy
// selector: the actual selector for finding an element
// mult: multiple elements or just one?
// context: finding an element from the root context? or starting from another element
//
// Returns an object which adheres to the way the JSON Wire Protocol represents elements:
// { ELEMENT: # }    eg: { ELEMENT: 3 }  or { ELEMENT: 1.023 }

helpers.findElOrElsWithProcessing = function callee$0$0(strategy, selector, mult, context) {
  var src;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        this.validateLocatorStrategy(strategy);
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.findElOrEls(strategy, selector, mult, context));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](1);

        if (!this.opts.printPageSourceOnFindFailure) {
          context$1$0.next = 16;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.getPageSource());

      case 12:
        src = context$1$0.sent;

        _logger2['default'].debug('Error finding element' + (mult ? 's' : '') + ': ' + context$1$0.t0.message);
        _logger2['default'].debug('Page source requested through \'printPageSourceOnFindFailure\':');
        _logger2['default'].debug(src);

      case 16:
        throw context$1$0.t0;

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 7]]);
};

commands.findElement = function callee$0$0(strategy, selector) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(strategy === IMAGE_STRATEGY)) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findByImage(selector, { multiple: false }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.findElOrElsWithProcessing(strategy, selector, false));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.findElements = function callee$0$0(strategy, selector) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!(strategy === IMAGE_STRATEGY)) {
          context$1$0.next = 4;
          break;
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.findByImage(selector, { multiple: true }));

      case 3:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.findElOrElsWithProcessing(strategy, selector, true));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.findElementFromElement = function callee$0$0(strategy, selector, elementId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.findElOrElsWithProcessing(strategy, selector, false, elementId));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

commands.findElementsFromElement = function callee$0$0(strategy, selector, elementId) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.findElOrElsWithProcessing(strategy, selector, true, elementId));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Object} FindByImageOptions
 * @property {boolean} [shouldCheckStaleness=false] - whether this call to find an
 * image is merely to check staleness. If so we can bypass a lot of logic
 * @property {boolean} [multiple=false] - Whether we are finding one element or
 * multiple
 */

/**
 * Find a screen rect represented by an ImageElement corresponding to an image
 * template sent in by the client
 *
 * @param {string} b64Template - base64-encoded image used as a template to be
 * matched in the screenshot
 * @param {FindByImageOptions} - additional options
 *
 * @returns {WebElement} - WebDriver element with a special id prefix
 */
helpers.findByImage = function callee$0$0(b64Template, _ref) {
  var _ref$shouldCheckStaleness = _ref.shouldCheckStaleness;
  var shouldCheckStaleness = _ref$shouldCheckStaleness === undefined ? false : _ref$shouldCheckStaleness;
  var _ref$multiple = _ref.multiple;
  var multiple = _ref$multiple === undefined ? false : _ref$multiple;

  var _settings$getSettings, threshold, fixImageTemplateSize, _ref2, screenWidth, screenHeight, rect, condition, imgEl, protoKey, protocolEl;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _settings$getSettings = this.settings.getSettings();
        threshold = _settings$getSettings.imageMatchThreshold;
        fixImageTemplateSize = _settings$getSettings.fixImageTemplateSize;

        _logger2['default'].info('Finding image element with match threshold ' + threshold);

        if (this.getWindowSize) {
          context$1$0.next = 6;
          break;
        }

        throw new Error("This driver does not support the required 'getWindowSize' command");

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getWindowSize());

      case 8:
        _ref2 = context$1$0.sent;
        screenWidth = _ref2.width;
        screenHeight = _ref2.height;

        if (!fixImageTemplateSize) {
          context$1$0.next = 15;
          break;
        }

        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(this.ensureTemplateSize(b64Template, screenWidth, screenHeight));

      case 14:
        b64Template = context$1$0.sent;

      case 15:
        rect = null;

        condition = function condition() {
          var b64Screenshot;
          return _regeneratorRuntime.async(function condition$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.getScreenshotForImageFind(screenWidth, screenHeight));

              case 3:
                b64Screenshot = context$2$0.sent;
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap(this.compareImages(_images.MATCH_TEMPLATE_MODE, b64Screenshot, b64Template, { threshold: threshold }));

              case 6:
                rect = context$2$0.sent.rect;
                return context$2$0.abrupt('return', true);

              case 10:
                context$2$0.prev = 10;
                context$2$0.t0 = context$2$0['catch'](0);

                if (!context$2$0.t0.message.match(/Cannot find any occurrences/)) {
                  context$2$0.next = 14;
                  break;
                }

                return context$2$0.abrupt('return', false);

              case 14:
                throw context$2$0.t0;

              case 15:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[0, 10]]);
        };

        context$1$0.prev = 17;
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(this.implicitWaitForCondition(condition));

      case 20:
        context$1$0.next = 26;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t0 = context$1$0['catch'](17);

        if (context$1$0.t0.message.match(/Condition unmet/)) {
          context$1$0.next = 26;
          break;
        }

        throw context$1$0.t0;

      case 26:
        if (rect) {
          context$1$0.next = 30;
          break;
        }

        if (!multiple) {
          context$1$0.next = 29;
          break;
        }

        return context$1$0.abrupt('return', []);

      case 29:
        throw new _.errors.NoSuchElementError();

      case 30:

        _logger2['default'].info('Image template matched: ' + JSON.stringify(rect));
        imgEl = new _imageElement.ImageElement(b64Template, rect);

        if (!shouldCheckStaleness) {
          context$1$0.next = 34;
          break;
        }

        return context$1$0.abrupt('return', imgEl);

      case 34:

        this._imgElCache.set(imgEl.id, imgEl);
        protoKey = this.isW3CProtocol() ? _protocolProtocol.W3C_ELEMENT_KEY : _protocolProtocol.MJSONWP_ELEMENT_KEY;
        protocolEl = imgEl.asElement(protoKey);
        return context$1$0.abrupt('return', multiple ? [protocolEl] : protocolEl);

      case 38:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[17, 22]]);
};

/**
 * Ensure that the image template sent in for a find is of a suitable size
 *
 * @param {string} b64Template - base64-encoded image
 * @param {int} screenWidth - width of screen
 * @param {int} screenHeight - height of screen
 *
 * @returns {string} base64-encoded image, potentially resized
 */
helpers.ensureTemplateSize = function callee$0$0(b64Template, screenWidth, screenHeight) {
  var imgObj, _imgObj$bitmap, tplWidth, tplHeight;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getJimpImage(b64Template));

      case 2:
        imgObj = context$1$0.sent;
        _imgObj$bitmap = imgObj.bitmap;
        tplWidth = _imgObj$bitmap.width;
        tplHeight = _imgObj$bitmap.height;

        if (!(tplWidth <= screenWidth && tplHeight <= screenHeight)) {
          context$1$0.next = 8;
          break;
        }

        return context$1$0.abrupt('return', b64Template);

      case 8:

        // otherwise, scale it to fit inside the screen dimensions
        imgObj = imgObj.scaleToFit(screenWidth, screenHeight);
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(imgObj.getBuffer(_appiumSupport.imageUtil.MIME_PNG));

      case 11:
        return context$1$0.abrupt('return', context$1$0.sent.toString('base64'));

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the screenshot image that will be used for find by element, potentially
 * altering it in various ways based on user-requested settings
 *
 * @param {int} screenWidth - width of screen
 * @param {int} screenHeight - height of screen
 *
 * @returns {string} base64-encoded screenshot
 */
helpers.getScreenshotForImageFind = function callee$0$0(screenWidth, screenHeight) {
  var b64Screenshot, imgObj, _imgObj$bitmap2, shotWidth, shotHeight, screenAR, shotAR;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (this.getScreenshot) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("This driver does not support the required 'getScreenshot' command");

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getScreenshot());

      case 4:
        b64Screenshot = context$1$0.sent;

        if (this.settings.getSettings().fixImageFindScreenshotDims) {
          context$1$0.next = 8;
          break;
        }

        _logger2['default'].info('Not verifying screenshot dimensions match screen');
        return context$1$0.abrupt('return', b64Screenshot);

      case 8:

        // otherwise, do some verification on the screenshot to make sure it matches
        // the screen size and aspect ratio
        _logger2['default'].info('Verifying screenshot size and aspect ratio');

        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getJimpImage(b64Screenshot));

      case 11:
        imgObj = context$1$0.sent;
        _imgObj$bitmap2 = imgObj.bitmap;
        shotWidth = _imgObj$bitmap2.width;
        shotHeight = _imgObj$bitmap2.height;

        if (!(screenWidth === shotWidth && screenHeight === shotHeight)) {
          context$1$0.next = 18;
          break;
        }

        // the height and width of the screenshot and the device screen match, which
        // means we should be safe when doing template matches
        _logger2['default'].info('Screenshot size matched screen size');
        return context$1$0.abrupt('return', b64Screenshot);

      case 18:
        screenAR = screenWidth / screenHeight;
        shotAR = shotWidth / shotHeight;

        if (screenAR === shotAR) {
          _logger2['default'].info('Screenshot aspect ratio matched screen aspect ratio');
        } else {
          _logger2['default'].warn('When trying to find an element, determined that the screen ' + 'aspect ratio and screenshot aspect ratio are different. Screen ' + ('is ' + screenWidth + 'x' + screenHeight + ' whereas screenshot is ') + (shotWidth + 'x' + shotHeight + '.'));
          shotWidth = shotWidth / (shotAR / screenAR);
          _logger2['default'].warn('Resizing screenshot to ' + shotWidth + 'x' + shotHeight + ' to match ' + 'screen aspect ratio so that image element coordinates have a ' + 'greater chance of being correct.');
          imgObj = imgObj.resize(shotWidth, shotHeight);
        }

        // now we know the aspect ratios match, but there might still be a scale
        // mismatch, so just resize based on the screen dimensions
        if (screenWidth !== shotWidth) {
          _logger2['default'].info('Scaling screenshot from ' + shotWidth + 'x' + shotHeight + ' to match ' + ('screen at ' + screenWidth + 'x' + screenHeight));
          imgObj = imgObj.resize(screenWidth, screenHeight);
        }

        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(imgObj.getBuffer(_appiumSupport.imageUtil.MIME_PNG));

      case 24:
        return context$1$0.abrupt('return', context$1$0.sent.toString('base64'));

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports.IMAGE_STRATEGY = IMAGE_STRATEGY;
exports['default'] = extensions;

// still want the error to occur

// someone might have sent in a template that's larger than the screen
// dimensions. If so let's check and cut it down to size since the algorithm
// will not work unless we do. But because it requires some potentially
// expensive commands, only do this if the user has requested it in settings.

// if compareImages fails, we'll get a specific error, but we should
// retry, so trap that and just return false to trigger the next round of
// implicitly waiting. For other errors, throw them to get out of the
// implicit wait loop

// this `implicitWaitForCondition` method will throw a 'Condition unmet'
// error if an element is not found eventually. In that case, we will
// handle the element not found response below. In the case where get some
// _other_ kind of error, it means something blew up totally apart from the
// implicit wait timeout. We should not mask that error and instead throw
// it straightaway

// if we're just checking staleness, return straightaway so we don't add
// a new element to the cache. shouldCheckStaleness does not support multiple
// elements, since it is a purely internal mechanism

// if the template fits inside the screen dimensions, we're good

// if the user has requested not to correct for aspect or size differences
// between the screenshot and the screen, just return the screenshot now

// otherwise, if they don't match, it could spell problems for the accuracy
// of coordinates returned by the image match algorithm, since we match based
// on the screenshot coordinates not the device coordinates themselves. There
// are two potential types of mismatch: aspect ratio mismatch and scale
// mismatch. we need to detect and fix both
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NvbW1hbmRzL2ZpbmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3NCQUFnQixXQUFXOzs7O2dCQUNKLFVBQVU7O3NCQUNHLFVBQVU7O2dDQUNPLHlCQUF5Qjs7NEJBQ2pELGtCQUFrQjs7NkJBQ3JCLGdCQUFnQjs7QUFHMUMsSUFBTSxRQUFRLEdBQUcsRUFBRTtJQUFFLE9BQU8sR0FBRyxFQUFFO0lBQUUsVUFBVSxHQUFHLEVBQUUsQ0FBQzs7QUFFbkQsSUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQWNoQyxPQUFPLENBQUMseUJBQXlCLEdBQUcsb0JBQWdCLFFBQVEsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU87TUFNekUsR0FBRzs7OztBQUxiLFlBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O3lDQUV4QixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQzs7Ozs7Ozs7O2FBRTVELElBQUksQ0FBQyxJQUFJLENBQUMsNEJBQTRCOzs7Ozs7eUNBQ3RCLElBQUksQ0FBQyxhQUFhLEVBQUU7OztBQUFoQyxXQUFHOztBQUNULDRCQUFJLEtBQUssNEJBQXlCLElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFBLFVBQUssZUFBSSxPQUFPLENBQUcsQ0FBQztBQUNyRSw0QkFBSSxLQUFLLG1FQUFpRSxDQUFDO0FBQzNFLDRCQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7OztDQUtwQixDQUFDOztBQUVGLFFBQVEsQ0FBQyxXQUFXLEdBQUcsb0JBQWdCLFFBQVEsRUFBRSxRQUFROzs7O2NBQ25ELFFBQVEsS0FBSyxjQUFjLENBQUE7Ozs7Ozt5Q0FDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsRUFBQyxRQUFRLEVBQUUsS0FBSyxFQUFDLENBQUM7Ozs7Ozs7eUNBRy9D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U0FBUyxTQUFJLFVBQVUsa0NBQ3JDLFdBQVcsU0FBSSxZQUFZLENBQUUsQ0FBQyxDQUFDO0FBQ3JELGdCQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFDLENBQUM7U0FDbkQ7Ozt5Q0FFYSxNQUFNLENBQUMsU0FBUyxDQUFDLHlCQUFVLFFBQVEsQ0FBQzs7OzZEQUFFLFFBQVEsQ0FBQyxRQUFROzs7Ozs7O0NBQ3RFLENBQUM7O0FBR0YsZUFBYyxVQUFVLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDLFFBQVEsR0FBUixRQUFRO1FBQUUsT0FBTyxHQUFQLE9BQU87UUFBRSxjQUFjLEdBQWQsY0FBYztxQkFDM0IsVUFBVSIsImZpbGUiOiJsaWIvYmFzZWRyaXZlci9jb21tYW5kcy9maW5kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgZXJyb3JzIH0gZnJvbSAnLi4vLi4vLi4nO1xuaW1wb3J0IHsgTUFUQ0hfVEVNUExBVEVfTU9ERSB9IGZyb20gJy4vaW1hZ2VzJztcbmltcG9ydCB7IFczQ19FTEVNRU5UX0tFWSwgTUpTT05XUF9FTEVNRU5UX0tFWSB9IGZyb20gJy4uLy4uL3Byb3RvY29sL3Byb3RvY29sJztcbmltcG9ydCB7IEltYWdlRWxlbWVudCB9IGZyb20gJy4uL2ltYWdlLWVsZW1lbnQnO1xuaW1wb3J0IHsgaW1hZ2VVdGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuXG5cbmNvbnN0IGNvbW1hbmRzID0ge30sIGhlbHBlcnMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBJTUFHRV9TVFJBVEVHWSA9IFwiLWltYWdlXCI7XG5cbi8vIE92ZXJyaWRlIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gZm9yIHlvdXIgb3duIGRyaXZlciwgYW5kIHRoZSByZXN0IGlzIHRha2VuXG4vLyBjYXJlIG9mIVxuXG4vL2hlbHBlcnMuZmluZEVsT3JFbHMgPSBhc3luYyBmdW5jdGlvbiAoc3RyYXRlZ3ksIHNlbGVjdG9yLCBtdWx0LCBjb250ZXh0KSB7fVxuLy8gc3RyYXRlZ3k6IGxvY2F0b3Igc3RyYXRlZ3lcbi8vIHNlbGVjdG9yOiB0aGUgYWN0dWFsIHNlbGVjdG9yIGZvciBmaW5kaW5nIGFuIGVsZW1lbnRcbi8vIG11bHQ6IG11bHRpcGxlIGVsZW1lbnRzIG9yIGp1c3Qgb25lP1xuLy8gY29udGV4dDogZmluZGluZyBhbiBlbGVtZW50IGZyb20gdGhlIHJvb3QgY29udGV4dD8gb3Igc3RhcnRpbmcgZnJvbSBhbm90aGVyIGVsZW1lbnRcbi8vXG4vLyBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBhZGhlcmVzIHRvIHRoZSB3YXkgdGhlIEpTT04gV2lyZSBQcm90b2NvbCByZXByZXNlbnRzIGVsZW1lbnRzOlxuLy8geyBFTEVNRU5UOiAjIH0gICAgZWc6IHsgRUxFTUVOVDogMyB9ICBvciB7IEVMRU1FTlQ6IDEuMDIzIH1cblxuaGVscGVycy5maW5kRWxPckVsc1dpdGhQcm9jZXNzaW5nID0gYXN5bmMgZnVuY3Rpb24gKHN0cmF0ZWd5LCBzZWxlY3RvciwgbXVsdCwgY29udGV4dCkge1xuICB0aGlzLnZhbGlkYXRlTG9jYXRvclN0cmF0ZWd5KHN0cmF0ZWd5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kRWxPckVscyhzdHJhdGVneSwgc2VsZWN0b3IsIG11bHQsIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodGhpcy5vcHRzLnByaW50UGFnZVNvdXJjZU9uRmluZEZhaWx1cmUpIHtcbiAgICAgIGNvbnN0IHNyYyA9IGF3YWl0IHRoaXMuZ2V0UGFnZVNvdXJjZSgpO1xuICAgICAgbG9nLmRlYnVnKGBFcnJvciBmaW5kaW5nIGVsZW1lbnQke211bHQgPyAncycgOiAnJ306ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICBsb2cuZGVidWcoYFBhZ2Ugc291cmNlIHJlcXVlc3RlZCB0aHJvdWdoICdwcmludFBhZ2VTb3VyY2VPbkZpbmRGYWlsdXJlJzpgKTtcbiAgICAgIGxvZy5kZWJ1ZyhzcmMpO1xuICAgIH1cbiAgICAvLyBzdGlsbCB3YW50IHRoZSBlcnJvciB0byBvY2N1clxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuY29tbWFuZHMuZmluZEVsZW1lbnQgPSBhc3luYyBmdW5jdGlvbiAoc3RyYXRlZ3ksIHNlbGVjdG9yKSB7XG4gIGlmIChzdHJhdGVneSA9PT0gSU1BR0VfU1RSQVRFR1kpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kQnlJbWFnZShzZWxlY3Rvciwge211bHRpcGxlOiBmYWxzZX0pO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZEVsT3JFbHNXaXRoUHJvY2Vzc2luZyhzdHJhdGVneSwgc2VsZWN0b3IsIGZhbHNlKTtcbn07XG5cbmNvbW1hbmRzLmZpbmRFbGVtZW50cyA9IGFzeW5jIGZ1bmN0aW9uIChzdHJhdGVneSwgc2VsZWN0b3IpIHtcbiAgaWYgKHN0cmF0ZWd5ID09PSBJTUFHRV9TVFJBVEVHWSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbmRCeUltYWdlKHNlbGVjdG9yLCB7bXVsdGlwbGU6IHRydWV9KTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCB0aGlzLmZpbmRFbE9yRWxzV2l0aFByb2Nlc3Npbmcoc3RyYXRlZ3ksIHNlbGVjdG9yLCB0cnVlKTtcbn07XG5cbmNvbW1hbmRzLmZpbmRFbGVtZW50RnJvbUVsZW1lbnQgPSBhc3luYyBmdW5jdGlvbiAoc3RyYXRlZ3ksIHNlbGVjdG9yLCBlbGVtZW50SWQpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZEVsT3JFbHNXaXRoUHJvY2Vzc2luZyhzdHJhdGVneSwgc2VsZWN0b3IsIGZhbHNlLCBlbGVtZW50SWQpO1xufTtcblxuY29tbWFuZHMuZmluZEVsZW1lbnRzRnJvbUVsZW1lbnQgPSBhc3luYyBmdW5jdGlvbiAoc3RyYXRlZ3ksIHNlbGVjdG9yLCBlbGVtZW50SWQpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZmluZEVsT3JFbHNXaXRoUHJvY2Vzc2luZyhzdHJhdGVneSwgc2VsZWN0b3IsIHRydWUsIGVsZW1lbnRJZCk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZpbmRCeUltYWdlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvdWxkQ2hlY2tTdGFsZW5lc3M9ZmFsc2VdIC0gd2hldGhlciB0aGlzIGNhbGwgdG8gZmluZCBhblxuICogaW1hZ2UgaXMgbWVyZWx5IHRvIGNoZWNrIHN0YWxlbmVzcy4gSWYgc28gd2UgY2FuIGJ5cGFzcyBhIGxvdCBvZiBsb2dpY1xuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlwbGU9ZmFsc2VdIC0gV2hldGhlciB3ZSBhcmUgZmluZGluZyBvbmUgZWxlbWVudCBvclxuICogbXVsdGlwbGVcbiAqL1xuXG4vKipcbiAqIEZpbmQgYSBzY3JlZW4gcmVjdCByZXByZXNlbnRlZCBieSBhbiBJbWFnZUVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhbiBpbWFnZVxuICogdGVtcGxhdGUgc2VudCBpbiBieSB0aGUgY2xpZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGI2NFRlbXBsYXRlIC0gYmFzZTY0LWVuY29kZWQgaW1hZ2UgdXNlZCBhcyBhIHRlbXBsYXRlIHRvIGJlXG4gKiBtYXRjaGVkIGluIHRoZSBzY3JlZW5zaG90XG4gKiBAcGFyYW0ge0ZpbmRCeUltYWdlT3B0aW9uc30gLSBhZGRpdGlvbmFsIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7V2ViRWxlbWVudH0gLSBXZWJEcml2ZXIgZWxlbWVudCB3aXRoIGEgc3BlY2lhbCBpZCBwcmVmaXhcbiAqL1xuaGVscGVycy5maW5kQnlJbWFnZSA9IGFzeW5jIGZ1bmN0aW9uIChiNjRUZW1wbGF0ZSwge1xuICBzaG91bGRDaGVja1N0YWxlbmVzcyA9IGZhbHNlLFxuICBtdWx0aXBsZSA9IGZhbHNlLFxufSkge1xuICBjb25zdCB7XG4gICAgaW1hZ2VNYXRjaFRocmVzaG9sZDogdGhyZXNob2xkLFxuICAgIGZpeEltYWdlVGVtcGxhdGVTaXplXG4gIH0gPSB0aGlzLnNldHRpbmdzLmdldFNldHRpbmdzKCk7XG5cbiAgbG9nLmluZm8oYEZpbmRpbmcgaW1hZ2UgZWxlbWVudCB3aXRoIG1hdGNoIHRocmVzaG9sZCAke3RocmVzaG9sZH1gKTtcbiAgaWYgKCF0aGlzLmdldFdpbmRvd1NpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGRyaXZlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1aXJlZCAnZ2V0V2luZG93U2l6ZScgY29tbWFuZFwiKTtcbiAgfVxuICBjb25zdCB7d2lkdGg6IHNjcmVlbldpZHRoLCBoZWlnaHQ6IHNjcmVlbkhlaWdodH0gPSBhd2FpdCB0aGlzLmdldFdpbmRvd1NpemUoKTtcblxuICAvLyBzb21lb25lIG1pZ2h0IGhhdmUgc2VudCBpbiBhIHRlbXBsYXRlIHRoYXQncyBsYXJnZXIgdGhhbiB0aGUgc2NyZWVuXG4gIC8vIGRpbWVuc2lvbnMuIElmIHNvIGxldCdzIGNoZWNrIGFuZCBjdXQgaXQgZG93biB0byBzaXplIHNpbmNlIHRoZSBhbGdvcml0aG1cbiAgLy8gd2lsbCBub3Qgd29yayB1bmxlc3Mgd2UgZG8uIEJ1dCBiZWNhdXNlIGl0IHJlcXVpcmVzIHNvbWUgcG90ZW50aWFsbHlcbiAgLy8gZXhwZW5zaXZlIGNvbW1hbmRzLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBpdCBpbiBzZXR0aW5ncy5cbiAgaWYgKGZpeEltYWdlVGVtcGxhdGVTaXplKSB7XG4gICAgYjY0VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmVuc3VyZVRlbXBsYXRlU2l6ZShiNjRUZW1wbGF0ZSwgc2NyZWVuV2lkdGgsXG4gICAgICBzY3JlZW5IZWlnaHQpO1xuICB9XG5cbiAgbGV0IHJlY3QgPSBudWxsO1xuICBjb25zdCBjb25kaXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBiNjRTY3JlZW5zaG90ID0gYXdhaXQgdGhpcy5nZXRTY3JlZW5zaG90Rm9ySW1hZ2VGaW5kKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuICAgICAgcmVjdCA9IChhd2FpdCB0aGlzLmNvbXBhcmVJbWFnZXMoTUFUQ0hfVEVNUExBVEVfTU9ERSwgYjY0U2NyZWVuc2hvdCxcbiAgICAgICAgYjY0VGVtcGxhdGUsIHt0aHJlc2hvbGR9KSkucmVjdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gaWYgY29tcGFyZUltYWdlcyBmYWlscywgd2UnbGwgZ2V0IGEgc3BlY2lmaWMgZXJyb3IsIGJ1dCB3ZSBzaG91bGRcbiAgICAgIC8vIHJldHJ5LCBzbyB0cmFwIHRoYXQgYW5kIGp1c3QgcmV0dXJuIGZhbHNlIHRvIHRyaWdnZXIgdGhlIG5leHQgcm91bmQgb2ZcbiAgICAgIC8vIGltcGxpY2l0bHkgd2FpdGluZy4gRm9yIG90aGVyIGVycm9ycywgdGhyb3cgdGhlbSB0byBnZXQgb3V0IG9mIHRoZVxuICAgICAgLy8gaW1wbGljaXQgd2FpdCBsb29wXG4gICAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL0Nhbm5vdCBmaW5kIGFueSBvY2N1cnJlbmNlcy8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmltcGxpY2l0V2FpdEZvckNvbmRpdGlvbihjb25kaXRpb24pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyB0aGlzIGBpbXBsaWNpdFdhaXRGb3JDb25kaXRpb25gIG1ldGhvZCB3aWxsIHRocm93IGEgJ0NvbmRpdGlvbiB1bm1ldCdcbiAgICAvLyBlcnJvciBpZiBhbiBlbGVtZW50IGlzIG5vdCBmb3VuZCBldmVudHVhbGx5LiBJbiB0aGF0IGNhc2UsIHdlIHdpbGxcbiAgICAvLyBoYW5kbGUgdGhlIGVsZW1lbnQgbm90IGZvdW5kIHJlc3BvbnNlIGJlbG93LiBJbiB0aGUgY2FzZSB3aGVyZSBnZXQgc29tZVxuICAgIC8vIF9vdGhlcl8ga2luZCBvZiBlcnJvciwgaXQgbWVhbnMgc29tZXRoaW5nIGJsZXcgdXAgdG90YWxseSBhcGFydCBmcm9tIHRoZVxuICAgIC8vIGltcGxpY2l0IHdhaXQgdGltZW91dC4gV2Ugc2hvdWxkIG5vdCBtYXNrIHRoYXQgZXJyb3IgYW5kIGluc3RlYWQgdGhyb3dcbiAgICAvLyBpdCBzdHJhaWdodGF3YXlcbiAgICBpZiAoIWVyci5tZXNzYWdlLm1hdGNoKC9Db25kaXRpb24gdW5tZXQvKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVjdCkge1xuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLk5vU3VjaEVsZW1lbnRFcnJvcigpO1xuICB9XG5cbiAgbG9nLmluZm8oYEltYWdlIHRlbXBsYXRlIG1hdGNoZWQ6ICR7SlNPTi5zdHJpbmdpZnkocmVjdCl9YCk7XG4gIGNvbnN0IGltZ0VsID0gbmV3IEltYWdlRWxlbWVudChiNjRUZW1wbGF0ZSwgcmVjdCk7XG5cbiAgLy8gaWYgd2UncmUganVzdCBjaGVja2luZyBzdGFsZW5lc3MsIHJldHVybiBzdHJhaWdodGF3YXkgc28gd2UgZG9uJ3QgYWRkXG4gIC8vIGEgbmV3IGVsZW1lbnQgdG8gdGhlIGNhY2hlLiBzaG91bGRDaGVja1N0YWxlbmVzcyBkb2VzIG5vdCBzdXBwb3J0IG11bHRpcGxlXG4gIC8vIGVsZW1lbnRzLCBzaW5jZSBpdCBpcyBhIHB1cmVseSBpbnRlcm5hbCBtZWNoYW5pc21cbiAgaWYgKHNob3VsZENoZWNrU3RhbGVuZXNzKSB7XG4gICAgcmV0dXJuIGltZ0VsO1xuICB9XG5cbiAgdGhpcy5faW1nRWxDYWNoZS5zZXQoaW1nRWwuaWQsIGltZ0VsKTtcbiAgY29uc3QgcHJvdG9LZXkgPSB0aGlzLmlzVzNDUHJvdG9jb2woKSA/IFczQ19FTEVNRU5UX0tFWSA6IE1KU09OV1BfRUxFTUVOVF9LRVk7XG4gIGNvbnN0IHByb3RvY29sRWwgPSBpbWdFbC5hc0VsZW1lbnQocHJvdG9LZXkpO1xuICByZXR1cm4gbXVsdGlwbGUgPyBbcHJvdG9jb2xFbF0gOiBwcm90b2NvbEVsO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgaW1hZ2UgdGVtcGxhdGUgc2VudCBpbiBmb3IgYSBmaW5kIGlzIG9mIGEgc3VpdGFibGUgc2l6ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiNjRUZW1wbGF0ZSAtIGJhc2U2NC1lbmNvZGVkIGltYWdlXG4gKiBAcGFyYW0ge2ludH0gc2NyZWVuV2lkdGggLSB3aWR0aCBvZiBzY3JlZW5cbiAqIEBwYXJhbSB7aW50fSBzY3JlZW5IZWlnaHQgLSBoZWlnaHQgb2Ygc2NyZWVuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gYmFzZTY0LWVuY29kZWQgaW1hZ2UsIHBvdGVudGlhbGx5IHJlc2l6ZWRcbiAqL1xuaGVscGVycy5lbnN1cmVUZW1wbGF0ZVNpemUgPSBhc3luYyBmdW5jdGlvbiAoYjY0VGVtcGxhdGUsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcbiAgbGV0IGltZ09iaiA9IGF3YWl0IGltYWdlVXRpbC5nZXRKaW1wSW1hZ2UoYjY0VGVtcGxhdGUpO1xuICBsZXQge3dpZHRoOiB0cGxXaWR0aCwgaGVpZ2h0OiB0cGxIZWlnaHR9ID0gaW1nT2JqLmJpdG1hcDtcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgZml0cyBpbnNpZGUgdGhlIHNjcmVlbiBkaW1lbnNpb25zLCB3ZSdyZSBnb29kXG4gIGlmICh0cGxXaWR0aCA8PSBzY3JlZW5XaWR0aCAmJiB0cGxIZWlnaHQgPD0gc2NyZWVuSGVpZ2h0KSB7XG4gICAgcmV0dXJuIGI2NFRlbXBsYXRlO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCBzY2FsZSBpdCB0byBmaXQgaW5zaWRlIHRoZSBzY3JlZW4gZGltZW5zaW9uc1xuICBpbWdPYmogPSBpbWdPYmouc2NhbGVUb0ZpdChzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcbiAgcmV0dXJuIChhd2FpdCBpbWdPYmouZ2V0QnVmZmVyKGltYWdlVXRpbC5NSU1FX1BORykpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzY3JlZW5zaG90IGltYWdlIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBmaW5kIGJ5IGVsZW1lbnQsIHBvdGVudGlhbGx5XG4gKiBhbHRlcmluZyBpdCBpbiB2YXJpb3VzIHdheXMgYmFzZWQgb24gdXNlci1yZXF1ZXN0ZWQgc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge2ludH0gc2NyZWVuV2lkdGggLSB3aWR0aCBvZiBzY3JlZW5cbiAqIEBwYXJhbSB7aW50fSBzY3JlZW5IZWlnaHQgLSBoZWlnaHQgb2Ygc2NyZWVuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gYmFzZTY0LWVuY29kZWQgc2NyZWVuc2hvdFxuICovXG5oZWxwZXJzLmdldFNjcmVlbnNob3RGb3JJbWFnZUZpbmQgPSBhc3luYyBmdW5jdGlvbiAoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuICBpZiAoIXRoaXMuZ2V0U2NyZWVuc2hvdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZHJpdmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVpcmVkICdnZXRTY3JlZW5zaG90JyBjb21tYW5kXCIpO1xuICB9XG5cbiAgbGV0IGI2NFNjcmVlbnNob3QgPSBhd2FpdCB0aGlzLmdldFNjcmVlbnNob3QoKTtcblxuICAvLyBpZiB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIG5vdCB0byBjb3JyZWN0IGZvciBhc3BlY3Qgb3Igc2l6ZSBkaWZmZXJlbmNlc1xuICAvLyBiZXR3ZWVuIHRoZSBzY3JlZW5zaG90IGFuZCB0aGUgc2NyZWVuLCBqdXN0IHJldHVybiB0aGUgc2NyZWVuc2hvdCBub3dcbiAgaWYgKCF0aGlzLnNldHRpbmdzLmdldFNldHRpbmdzKCkuZml4SW1hZ2VGaW5kU2NyZWVuc2hvdERpbXMpIHtcbiAgICBsb2cuaW5mbyhgTm90IHZlcmlmeWluZyBzY3JlZW5zaG90IGRpbWVuc2lvbnMgbWF0Y2ggc2NyZWVuYCk7XG4gICAgcmV0dXJuIGI2NFNjcmVlbnNob3Q7XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIGRvIHNvbWUgdmVyaWZpY2F0aW9uIG9uIHRoZSBzY3JlZW5zaG90IHRvIG1ha2Ugc3VyZSBpdCBtYXRjaGVzXG4gIC8vIHRoZSBzY3JlZW4gc2l6ZSBhbmQgYXNwZWN0IHJhdGlvXG4gIGxvZy5pbmZvKCdWZXJpZnlpbmcgc2NyZWVuc2hvdCBzaXplIGFuZCBhc3BlY3QgcmF0aW8nKTtcblxuICBsZXQgaW1nT2JqID0gYXdhaXQgaW1hZ2VVdGlsLmdldEppbXBJbWFnZShiNjRTY3JlZW5zaG90KTtcbiAgbGV0IHt3aWR0aDogc2hvdFdpZHRoLCBoZWlnaHQ6IHNob3RIZWlnaHR9ID0gaW1nT2JqLmJpdG1hcDtcblxuICBpZiAoc2NyZWVuV2lkdGggPT09IHNob3RXaWR0aCAmJiBzY3JlZW5IZWlnaHQgPT09IHNob3RIZWlnaHQpIHtcbiAgICAvLyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgc2NyZWVuc2hvdCBhbmQgdGhlIGRldmljZSBzY3JlZW4gbWF0Y2gsIHdoaWNoXG4gICAgLy8gbWVhbnMgd2Ugc2hvdWxkIGJlIHNhZmUgd2hlbiBkb2luZyB0ZW1wbGF0ZSBtYXRjaGVzXG4gICAgbG9nLmluZm8oJ1NjcmVlbnNob3Qgc2l6ZSBtYXRjaGVkIHNjcmVlbiBzaXplJyk7XG4gICAgcmV0dXJuIGI2NFNjcmVlbnNob3Q7XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIGlmIHRoZXkgZG9uJ3QgbWF0Y2gsIGl0IGNvdWxkIHNwZWxsIHByb2JsZW1zIGZvciB0aGUgYWNjdXJhY3lcbiAgLy8gb2YgY29vcmRpbmF0ZXMgcmV0dXJuZWQgYnkgdGhlIGltYWdlIG1hdGNoIGFsZ29yaXRobSwgc2luY2Ugd2UgbWF0Y2ggYmFzZWRcbiAgLy8gb24gdGhlIHNjcmVlbnNob3QgY29vcmRpbmF0ZXMgbm90IHRoZSBkZXZpY2UgY29vcmRpbmF0ZXMgdGhlbXNlbHZlcy4gVGhlcmVcbiAgLy8gYXJlIHR3byBwb3RlbnRpYWwgdHlwZXMgb2YgbWlzbWF0Y2g6IGFzcGVjdCByYXRpbyBtaXNtYXRjaCBhbmQgc2NhbGVcbiAgLy8gbWlzbWF0Y2guIHdlIG5lZWQgdG8gZGV0ZWN0IGFuZCBmaXggYm90aFxuXG4gIGNvbnN0IHNjcmVlbkFSID0gc2NyZWVuV2lkdGggLyBzY3JlZW5IZWlnaHQ7XG4gIGNvbnN0IHNob3RBUiA9IHNob3RXaWR0aCAvIHNob3RIZWlnaHQ7XG5cbiAgaWYgKHNjcmVlbkFSID09PSBzaG90QVIpIHtcbiAgICBsb2cuaW5mbygnU2NyZWVuc2hvdCBhc3BlY3QgcmF0aW8gbWF0Y2hlZCBzY3JlZW4gYXNwZWN0IHJhdGlvJyk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLndhcm4oYFdoZW4gdHJ5aW5nIHRvIGZpbmQgYW4gZWxlbWVudCwgZGV0ZXJtaW5lZCB0aGF0IHRoZSBzY3JlZW4gYCArXG4gICAgICAgICAgICAgYGFzcGVjdCByYXRpbyBhbmQgc2NyZWVuc2hvdCBhc3BlY3QgcmF0aW8gYXJlIGRpZmZlcmVudC4gU2NyZWVuIGAgK1xuICAgICAgICAgICAgIGBpcyAke3NjcmVlbldpZHRofXgke3NjcmVlbkhlaWdodH0gd2hlcmVhcyBzY3JlZW5zaG90IGlzIGAgK1xuICAgICAgICAgICAgIGAke3Nob3RXaWR0aH14JHtzaG90SGVpZ2h0fS5gKTtcbiAgICBzaG90V2lkdGggPSBzaG90V2lkdGggLyAoc2hvdEFSIC8gc2NyZWVuQVIpO1xuICAgIGxvZy53YXJuKGBSZXNpemluZyBzY3JlZW5zaG90IHRvICR7c2hvdFdpZHRofXgke3Nob3RIZWlnaHR9IHRvIG1hdGNoIGAgK1xuICAgICAgICAgICAgIGBzY3JlZW4gYXNwZWN0IHJhdGlvIHNvIHRoYXQgaW1hZ2UgZWxlbWVudCBjb29yZGluYXRlcyBoYXZlIGEgYCArXG4gICAgICAgICAgICAgYGdyZWF0ZXIgY2hhbmNlIG9mIGJlaW5nIGNvcnJlY3QuYCk7XG4gICAgaW1nT2JqID0gaW1nT2JqLnJlc2l6ZShzaG90V2lkdGgsIHNob3RIZWlnaHQpO1xuICB9XG5cbiAgLy8gbm93IHdlIGtub3cgdGhlIGFzcGVjdCByYXRpb3MgbWF0Y2gsIGJ1dCB0aGVyZSBtaWdodCBzdGlsbCBiZSBhIHNjYWxlXG4gIC8vIG1pc21hdGNoLCBzbyBqdXN0IHJlc2l6ZSBiYXNlZCBvbiB0aGUgc2NyZWVuIGRpbWVuc2lvbnNcbiAgaWYgKHNjcmVlbldpZHRoICE9PSBzaG90V2lkdGgpIHtcbiAgICBsb2cuaW5mbyhgU2NhbGluZyBzY3JlZW5zaG90IGZyb20gJHtzaG90V2lkdGh9eCR7c2hvdEhlaWdodH0gdG8gbWF0Y2ggYCArXG4gICAgICAgICAgICAgYHNjcmVlbiBhdCAke3NjcmVlbldpZHRofXgke3NjcmVlbkhlaWdodH1gKTtcbiAgICBpbWdPYmogPSBpbWdPYmoucmVzaXplKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIChhd2FpdCBpbWdPYmouZ2V0QnVmZmVyKGltYWdlVXRpbC5NSU1FX1BORykpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn07XG5cblxuT2JqZWN0LmFzc2lnbihleHRlbnNpb25zLCBjb21tYW5kcywgaGVscGVycyk7XG5leHBvcnQgeyBjb21tYW5kcywgaGVscGVycywgSU1BR0VfU1RSQVRFR1kgfTtcbmV4cG9ydCBkZWZhdWx0IGV4dGVuc2lvbnM7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uLy4uIn0=
