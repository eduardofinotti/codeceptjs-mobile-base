'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _protocolErrors = require('../../protocol/errors');

var _appiumSupport = require('appium-support');

var commands = {},
    helpers = {},
    extensions = {};

var MATCH_FEATURES_MODE = 'matchFeatures';
var GET_SIMILARITY_MODE = 'getSimilarity';
var MATCH_TEMPLATE_MODE = 'matchTemplate';

var DEFAULT_MATCH_THRESHOLD = 0.4;

/**
 * Performs images comparison using OpenCV framework features.
 * It is expected that both OpenCV framework and opencv4nodejs
 * module are installed on the machine where Appium server is running.
 *
 * @param {string} mode - One of possible comparison modes:
 * matchFeatures, getSimilarity, matchTemplate
 * @param {string} firstImage - Base64-encoded image file.
 * All image formats, that OpenCV library itself accepts, are supported.
 * @param {string} secondImage - Base64-encoded image file.
 * All image formats, that OpenCV library itself accepts, are supported.
 * @param {?Object} options [{}] - The content of this dictionary depends
 * on the actual `mode` value. See the documentation on `appium-support`
 * module for more details.
 * @returns {Object} The content of the resulting dictionary depends
 * on the actual `mode` and `options` values. See the documentation on
 * `appium-support` module for more details.
 * @throws {Error} If required OpenCV modules are not installed or
 * if `mode` value is incorrect or if there was an unexpected issue while
 * matching the images.
 */
commands.compareImages = function callee$0$0(mode, firstImage, secondImage) {
  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
  var img1, img2, result;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        img1 = Buffer.from(firstImage, 'base64');
        img2 = Buffer.from(secondImage, 'base64');
        result = {};
        context$1$0.t0 = _lodash2['default'].toLower(mode);
        context$1$0.next = context$1$0.t0 === MATCH_FEATURES_MODE.toLowerCase() ? 6 : context$1$0.t0 === GET_SIMILARITY_MODE.toLowerCase() ? 10 : context$1$0.t0 === MATCH_TEMPLATE_MODE.toLowerCase() ? 14 : 18;
        break;

      case 6:
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getImagesMatches(img1, img2, options));

      case 8:
        result = context$1$0.sent;
        return context$1$0.abrupt('break', 19);

      case 10:
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getImagesSimilarity(img1, img2, options));

      case 12:
        result = context$1$0.sent;
        return context$1$0.abrupt('break', 19);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap(_appiumSupport.imageUtil.getImageOccurrence(img1, img2, options));

      case 16:
        result = context$1$0.sent;
        return context$1$0.abrupt('break', 19);

      case 18:
        throw new _protocolErrors.errors.InvalidArgumentError('\'' + mode + '\' images comparison mode is unknown. ' + ('Only ' + JSON.stringify([MATCH_FEATURES_MODE, GET_SIMILARITY_MODE, MATCH_TEMPLATE_MODE]) + ' modes are supported.'));

      case 19:
        if (!_lodash2['default'].isEmpty(result.visualization)) {
          result.visualization = result.visualization.toString('base64');
        }
        return context$1$0.abrupt('return', result);

      case 21:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

_Object$assign(extensions, commands, helpers);
exports.commands = commands;
exports.helpers = helpers;
exports.DEFAULT_MATCH_THRESHOLD = DEFAULT_MATCH_THRESHOLD;
exports.MATCH_TEMPLATE_MODE = MATCH_TEMPLATE_MODE;
exports['default'] = extensions;

// firstImage/img1 is the full image and secondImage/img2 is the partial one
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NvbW1hbmRzL2ltYWdlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7c0JBQWMsUUFBUTs7Ozs4QkFDQyx1QkFBdUI7OzZCQUNwQixnQkFBZ0I7O0FBRTFDLElBQU0sUUFBUSxHQUFHLEVBQUU7SUFBRSxPQUFPLEdBQUcsRUFBRTtJQUFFLFVBQVUsR0FBRyxFQUFFLENBQUM7O0FBRW5ELElBQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDO0FBQzVDLElBQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDO0FBQzVDLElBQU0sbUJBQW1CLEdBQUcsZUFBZSxDQUFDOztBQUU1QyxJQUFNLHVCQUF1QixHQUFHLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QnBDLFFBQVEsQ0FBQyxhQUFhLEdBQUcsb0JBQWdCLElBQUksRUFBRSxVQUFVLEVBQUUsV0FBVztNQUFFLE9BQU8seURBQUcsRUFBRTtNQUM1RSxJQUFJLEVBQ0osSUFBSSxFQUNOLE1BQU07Ozs7QUFGSixZQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDO0FBQ3hDLFlBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUM7QUFDM0MsY0FBTSxHQUFHLEVBQUU7eUJBQ1Asb0JBQUUsT0FBTyxDQUFDLElBQUksQ0FBQzs4Q0FDaEIsbUJBQW1CLENBQUMsV0FBVyxFQUFFLDBCQUdqQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsMkJBR2pDLG1CQUFtQixDQUFDLFdBQVcsRUFBRTs7Ozs7eUNBTHJCLHlCQUFVLGdCQUFnQixDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDOzs7QUFBOUQsY0FBTTs7Ozs7eUNBR1MseUJBQVUsbUJBQW1CLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7OztBQUFqRSxjQUFNOzs7Ozt5Q0FJUyx5QkFBVSxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQzs7O0FBQWhFLGNBQU07Ozs7Y0FHQSxJQUFJLHVCQUFPLG9CQUFvQixDQUFDLE9BQUksSUFBSSx5REFDcEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixDQUFDLENBQUMsMkJBQXVCLENBQUM7OztBQUVySCxZQUFJLENBQUMsb0JBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRTtBQUNwQyxnQkFBTSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNoRTs0Q0FDTSxNQUFNOzs7Ozs7O0NBQ2QsQ0FBQzs7QUFFRixlQUFjLFVBQVUsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDcEMsUUFBUSxHQUFSLFFBQVE7UUFBRSxPQUFPLEdBQVAsT0FBTztRQUFFLHVCQUF1QixHQUF2Qix1QkFBdUI7UUFBRSxtQkFBbUIsR0FBbkIsbUJBQW1CO3FCQUN6RCxVQUFVIiwiZmlsZSI6ImxpYi9iYXNlZHJpdmVyL2NvbW1hbmRzL2ltYWdlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBlcnJvcnMgfSBmcm9tICcuLi8uLi9wcm90b2NvbC9lcnJvcnMnO1xuaW1wb3J0IHsgaW1hZ2VVdGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuXG5jb25zdCBjb21tYW5kcyA9IHt9LCBoZWxwZXJzID0ge30sIGV4dGVuc2lvbnMgPSB7fTtcblxuY29uc3QgTUFUQ0hfRkVBVFVSRVNfTU9ERSA9ICdtYXRjaEZlYXR1cmVzJztcbmNvbnN0IEdFVF9TSU1JTEFSSVRZX01PREUgPSAnZ2V0U2ltaWxhcml0eSc7XG5jb25zdCBNQVRDSF9URU1QTEFURV9NT0RFID0gJ21hdGNoVGVtcGxhdGUnO1xuXG5jb25zdCBERUZBVUxUX01BVENIX1RIUkVTSE9MRCA9IDAuNDtcblxuLyoqXG4gKiBQZXJmb3JtcyBpbWFnZXMgY29tcGFyaXNvbiB1c2luZyBPcGVuQ1YgZnJhbWV3b3JrIGZlYXR1cmVzLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCBib3RoIE9wZW5DViBmcmFtZXdvcmsgYW5kIG9wZW5jdjRub2RlanNcbiAqIG1vZHVsZSBhcmUgaW5zdGFsbGVkIG9uIHRoZSBtYWNoaW5lIHdoZXJlIEFwcGl1bSBzZXJ2ZXIgaXMgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIE9uZSBvZiBwb3NzaWJsZSBjb21wYXJpc29uIG1vZGVzOlxuICogbWF0Y2hGZWF0dXJlcywgZ2V0U2ltaWxhcml0eSwgbWF0Y2hUZW1wbGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpcnN0SW1hZ2UgLSBCYXNlNjQtZW5jb2RlZCBpbWFnZSBmaWxlLlxuICogQWxsIGltYWdlIGZvcm1hdHMsIHRoYXQgT3BlbkNWIGxpYnJhcnkgaXRzZWxmIGFjY2VwdHMsIGFyZSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2Vjb25kSW1hZ2UgLSBCYXNlNjQtZW5jb2RlZCBpbWFnZSBmaWxlLlxuICogQWxsIGltYWdlIGZvcm1hdHMsIHRoYXQgT3BlbkNWIGxpYnJhcnkgaXRzZWxmIGFjY2VwdHMsIGFyZSBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0gez9PYmplY3R9IG9wdGlvbnMgW3t9XSAtIFRoZSBjb250ZW50IG9mIHRoaXMgZGljdGlvbmFyeSBkZXBlbmRzXG4gKiBvbiB0aGUgYWN0dWFsIGBtb2RlYCB2YWx1ZS4gU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9uIGBhcHBpdW0tc3VwcG9ydGBcbiAqIG1vZHVsZSBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIGNvbnRlbnQgb2YgdGhlIHJlc3VsdGluZyBkaWN0aW9uYXJ5IGRlcGVuZHNcbiAqIG9uIHRoZSBhY3R1YWwgYG1vZGVgIGFuZCBgb3B0aW9uc2AgdmFsdWVzLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gb25cbiAqIGBhcHBpdW0tc3VwcG9ydGAgbW9kdWxlIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgT3BlbkNWIG1vZHVsZXMgYXJlIG5vdCBpbnN0YWxsZWQgb3JcbiAqIGlmIGBtb2RlYCB2YWx1ZSBpcyBpbmNvcnJlY3Qgb3IgaWYgdGhlcmUgd2FzIGFuIHVuZXhwZWN0ZWQgaXNzdWUgd2hpbGVcbiAqIG1hdGNoaW5nIHRoZSBpbWFnZXMuXG4gKi9cbmNvbW1hbmRzLmNvbXBhcmVJbWFnZXMgPSBhc3luYyBmdW5jdGlvbiAobW9kZSwgZmlyc3RJbWFnZSwgc2Vjb25kSW1hZ2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpbWcxID0gQnVmZmVyLmZyb20oZmlyc3RJbWFnZSwgJ2Jhc2U2NCcpO1xuICBjb25zdCBpbWcyID0gQnVmZmVyLmZyb20oc2Vjb25kSW1hZ2UsICdiYXNlNjQnKTtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBzd2l0Y2ggKF8udG9Mb3dlcihtb2RlKSkge1xuICAgIGNhc2UgTUFUQ0hfRkVBVFVSRVNfTU9ERS50b0xvd2VyQ2FzZSgpOlxuICAgICAgcmVzdWx0ID0gYXdhaXQgaW1hZ2VVdGlsLmdldEltYWdlc01hdGNoZXMoaW1nMSwgaW1nMiwgb3B0aW9ucyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEdFVF9TSU1JTEFSSVRZX01PREUudG9Mb3dlckNhc2UoKTpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGltYWdlVXRpbC5nZXRJbWFnZXNTaW1pbGFyaXR5KGltZzEsIGltZzIsIG9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBNQVRDSF9URU1QTEFURV9NT0RFLnRvTG93ZXJDYXNlKCk6XG4gICAgICAvLyBmaXJzdEltYWdlL2ltZzEgaXMgdGhlIGZ1bGwgaW1hZ2UgYW5kIHNlY29uZEltYWdlL2ltZzIgaXMgdGhlIHBhcnRpYWwgb25lXG4gICAgICByZXN1bHQgPSBhd2FpdCBpbWFnZVV0aWwuZ2V0SW1hZ2VPY2N1cnJlbmNlKGltZzEsIGltZzIsIG9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoYCcke21vZGV9JyBpbWFnZXMgY29tcGFyaXNvbiBtb2RlIGlzIHVua25vd24uIGAgK1xuICAgICAgICBgT25seSAke0pTT04uc3RyaW5naWZ5KFtNQVRDSF9GRUFUVVJFU19NT0RFLCBHRVRfU0lNSUxBUklUWV9NT0RFLCBNQVRDSF9URU1QTEFURV9NT0RFXSl9IG1vZGVzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkocmVzdWx0LnZpc3VhbGl6YXRpb24pKSB7XG4gICAgcmVzdWx0LnZpc3VhbGl6YXRpb24gPSByZXN1bHQudmlzdWFsaXphdGlvbi50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9iamVjdC5hc3NpZ24oZXh0ZW5zaW9ucywgY29tbWFuZHMsIGhlbHBlcnMpO1xuZXhwb3J0IHsgY29tbWFuZHMsIGhlbHBlcnMsIERFRkFVTFRfTUFUQ0hfVEhSRVNIT0xELCBNQVRDSF9URU1QTEFURV9NT0RFIH07XG5leHBvcnQgZGVmYXVsdCBleHRlbnNpb25zO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLi8uLiJ9
