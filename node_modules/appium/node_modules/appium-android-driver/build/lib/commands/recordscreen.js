'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _fs2 = require('fs');

var _fs3 = _interopRequireDefault(_fs2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _asyncbox = require('asyncbox');

var _appiumSupport = require('appium-support');

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _v8 = require('v8');

var _v82 = _interopRequireDefault(_v8);

var commands = {},
    extensions = {};

var RETRY_PAUSE = 300;
var RETRY_TIMEOUT = 5000;
var MAX_RECORDING_TIME_SEC = 60 * 3;
var MAX_TIME_SEC = 60 * 30;
var DEFAULT_RECORDING_TIME_SEC = MAX_RECORDING_TIME_SEC;
var PROCESS_SHUTDOWN_TIMEOUT_SEC = 5;
var SCREENRECORD_BINARY = 'screenrecord';
var DEFAULT_EXT = '.mp4';
var MIN_EMULATOR_API_LEVEL = 27;
var FFMPEG_BINARY = 'ffmpeg' + (_appiumSupport.system.isWindows() ? '.exe' : '');

function uploadRecordedMedia(adb, localFile) {
  var remotePath = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
  var uploadOptions = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var _ref, size, maxMemoryLimit, remoteUrl, options, user, pass, method;

  return _regeneratorRuntime.async(function uploadRecordedMedia$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(localFile));

      case 2:
        _ref = context$1$0.sent;
        size = _ref.size;

        _logger2['default'].debug('The size of the resulting screen recording is ' + _appiumSupport.util.toReadableSizeString(size));

        if (!_lodash2['default'].isEmpty(remotePath)) {
          context$1$0.next = 11;
          break;
        }

        maxMemoryLimit = _v82['default'].getHeapStatistics().total_available_size / 2;

        if (size >= maxMemoryLimit) {
          _logger2['default'].info('The file might be too large to fit into the process memory ' + ('(' + _appiumSupport.util.toReadableSizeString(size) + ' >= ' + _appiumSupport.util.toReadableSizeString(maxMemoryLimit) + '). ') + 'Provide a link to a remote writable location for video upload ' + '(http(s) and ftp protocols are supported) if you experience Out Of Memory errors');
        }
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(localFile));

      case 10:
        return context$1$0.abrupt('return', context$1$0.sent.toString('base64'));

      case 11:
        remoteUrl = _url2['default'].parse(remotePath);
        options = {};
        user = uploadOptions.user;
        pass = uploadOptions.pass;
        method = uploadOptions.method;

        if (remoteUrl.protocol.startsWith('http')) {
          options = {
            url: remoteUrl.href,
            method: method || 'PUT',
            multipart: [{ body: _fs3['default'].createReadStream(localFile) }]
          };
          if (user && pass) {
            options.auth = { user: user, pass: pass };
          }
        } else if (remoteUrl.protocol.startsWith('ftp')) {
          options = {
            host: remoteUrl.hostname,
            port: remoteUrl.port || 21
          };
          if (user && pass) {
            options.user = user;
            options.pass = pass;
          }
        }
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_appiumSupport.net.uploadFile(localFile, remotePath, options));

      case 19:
        return context$1$0.abrupt('return', '');

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function verifyScreenRecordIsSupported(adb, isEmulator) {
  var apiLevel;
  return _regeneratorRuntime.async(function verifyScreenRecordIsSupported$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(adb.getApiLevel());

      case 2:
        apiLevel = context$1$0.sent;

        if (!(isEmulator && apiLevel < MIN_EMULATOR_API_LEVEL)) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Screen recording does not work on emulators running Android API level less than ' + MIN_EMULATOR_API_LEVEL);

      case 5:
        if (!(apiLevel < 19)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error('Screen recording not available on API Level ' + apiLevel + '. Minimum API Level is 19.');

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function scheduleScreenRecord(adb, recordingProperties) {
  var startTimestamp, videoSize, bitRate, timeLimit, bugReport, currentTimeLimit, currentTimeLimitInt, pathOnDevice, recordingProc;
  return _regeneratorRuntime.async(function scheduleScreenRecord$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!recordingProperties.stopped) {
          context$1$0.next = 2;
          break;
        }

        return context$1$0.abrupt('return');

      case 2:
        startTimestamp = recordingProperties.startTimestamp;
        videoSize = recordingProperties.videoSize;
        bitRate = recordingProperties.bitRate;
        timeLimit = recordingProperties.timeLimit;
        bugReport = recordingProperties.bugReport;
        currentTimeLimit = MAX_RECORDING_TIME_SEC;

        if (_appiumSupport.util.hasValue(recordingProperties.currentTimeLimit)) {
          currentTimeLimitInt = parseInt(recordingProperties.currentTimeLimit, 10);

          if (!isNaN(currentTimeLimitInt) && currentTimeLimitInt < MAX_RECORDING_TIME_SEC) {
            currentTimeLimit = currentTimeLimitInt;
          }
        }
        pathOnDevice = '/sdcard/' + Math.floor(new Date()) + DEFAULT_EXT;
        recordingProc = adb.screenrecord(pathOnDevice, {
          videoSize: videoSize,
          bitRate: bitRate,
          timeLimit: currentTimeLimit,
          bugReport: bugReport
        });

        recordingProc.on('end', function () {
          if (recordingProperties.stopped || !_appiumSupport.util.hasValue(timeLimit)) {
            return;
          }
          var currentDuration = process.hrtime(startTimestamp)[0];
          _logger2['default'].debug('The overall screen recording duration is ' + currentDuration + 's so far');
          var timeLimitInt = parseInt(timeLimit, 10);
          if (isNaN(timeLimitInt) || currentDuration >= timeLimitInt) {
            _logger2['default'].debug('There is no need to start the next recording chunk');
            return;
          }

          recordingProperties.currentTimeLimit = timeLimitInt - currentDuration;
          var chunkDuration = recordingProperties.currentTimeLimit < MAX_RECORDING_TIME_SEC ? recordingProperties.currentTimeLimit : MAX_RECORDING_TIME_SEC;
          _logger2['default'].debug('Starting the next ' + chunkDuration + 's-chunk ' + ('of screen recording in order to achieve ' + timeLimitInt + 's total duration'));
          scheduleScreenRecord(adb, recordingProperties)['catch'](function (e) {
            _logger2['default'].error(e.stack);
            recordingProperties.stopped = true;
          });
        });

        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(recordingProc.start(0));

      case 14:
        context$1$0.prev = 14;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _asyncbox.waitForCondition)(function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(adb.fileExists(pathOnDevice));

              case 2:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 3:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, { waitMs: RETRY_TIMEOUT, intervalMs: RETRY_PAUSE }));

      case 17:
        context$1$0.next = 22;
        break;

      case 19:
        context$1$0.prev = 19;
        context$1$0.t0 = context$1$0['catch'](14);
        throw new Error('The expected screen record file \'' + pathOnDevice + '\' does not exist after ' + RETRY_TIMEOUT + 'ms');

      case 22:

        recordingProperties.records.push(pathOnDevice);
        recordingProperties.recordingProcess = recordingProc;

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[14, 19]]);
}

function mergeScreenRecords(mediaFiles) {
  var configContent, configFile, result, args;
  return _regeneratorRuntime.async(function mergeScreenRecords$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.which(FFMPEG_BINARY));

      case 3:
        context$1$0.next = 8;
        break;

      case 5:
        context$1$0.prev = 5;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error(FFMPEG_BINARY + ' utility is not available in PATH. Please install it from https://www.ffmpeg.org/');

      case 8:
        configContent = mediaFiles.map(function (x) {
          return 'file \'' + x + '\'';
        }).join('\n');
        configFile = _path2['default'].resolve(_path2['default'].dirname(mediaFiles[0]), 'config.txt');
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(configFile, configContent, 'utf8'));

      case 12:
        _logger2['default'].debug('Generated ffmpeg merging config \'' + configFile + '\' with items:\n' + configContent);
        result = _path2['default'].resolve(_path2['default'].dirname(mediaFiles[0]), 'merge_' + Math.floor(new Date()) + DEFAULT_EXT);
        args = ['-safe', '0', '-f', 'concat', '-i', configFile, '-c', 'copy', result];

        _logger2['default'].info('Initiating screen records merging using the command \'' + FFMPEG_BINARY + ' ' + args.join(' ') + '\'');
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(FFMPEG_BINARY, args));

      case 18:
        return context$1$0.abrupt('return', result);

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 5]]);
}

function terminateBackgroundScreenRecording(adb) {
  var pids;
  return _regeneratorRuntime.async(function terminateBackgroundScreenRecording$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(adb.getPIDsByName(SCREENRECORD_BINARY));

      case 2:
        context$1$0.t0 = function (p) {
          return '' + p;
        };

        pids = context$1$0.sent.map(context$1$0.t0);

        if (!_lodash2['default'].isEmpty(pids)) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', false);

      case 6:
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(adb.shell(['kill'].concat(_toConsumableArray(pids))));

      case 9:
        return context$1$0.abrupt('return', true);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t1 = context$1$0['catch'](6);
        throw new Error('Unable to stop the background screen recording: ' + context$1$0.t1.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 12]]);
}

/**
 * @typedef {Object} StartRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the captured video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 *                                  This option only has an effect if there is screen recording process in progreess
 *                                  and `forceRestart` parameter is not set to `true`.
 * @property {?string} user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 *                              Only works if `remotePath` is provided.
 * @property {?string} videoSize - The format is widthxheight.
 *                  The default value is the device's native display resolution (if supported),
 *                  1280x720 if not. For best results,
 *                  use a size supported by your device's Advanced Video Coding (AVC) encoder.
 *                  For example, "1280x720"
 * @property {?boolean} bugReport - Set it to `true` in order to display additional information on the video overlay,
 *                                  such as a timestamp, that is helpful in videos captured to illustrate bugs.
 *                                  This option is only supported since API level 27 (Android P).
 * @property {?string|number} timeLimit - The maximum recording time, in seconds. The default value is 180 (3 minutes).
 *                                        The maximum value is 1800 (30 minutes). If the passed value is greater than 180 then
 *                                        the algorithm will try to schedule multiple screen recording chunks and merge the
 *                                        resulting videos into a single media file using `ffmpeg` utility.
 *                                        If the utility is not available in PATH then the most recent screen recording chunk is
 *                                        going to be returned.
 * @property {?string|number} bitRate - The video bit rate for the video, in megabits per second.
 *                The default value is 4. You can increase the bit rate to improve video quality,
 *                but doing so results in larger movie files.
 * @property {?boolean} forceRestart - Whether to try to catch and upload/return the currently running screen recording
 *                                     (`false`, the default setting) or ignore the result of it and start a new recording
 *                                     immediately (`true`).
 */

/**
 * Record the display of a real devices running Android 4.4 (API level 19) and higher.
 * Emulators are supported since API level 27 (Android P).
 * It records screen activity to an MPEG-4 file. Audio is not recorded with the video file.
 * If screen recording has been already started then the command will stop it forcefully and start a new one.
 * The previously recorded video file will be deleted.
 *
 * @param {?StartRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if
 *                   any screen recording is currently running or an empty string.
 * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
 */
commands.startRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var result, videoSize, _options$timeLimit, timeLimit, bugReport, bitRate, forceRestart, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, record, timeout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 2:
        result = '';
        videoSize = options.videoSize;
        _options$timeLimit = options.timeLimit;
        timeLimit = _options$timeLimit === undefined ? DEFAULT_RECORDING_TIME_SEC : _options$timeLimit;
        bugReport = options.bugReport;
        bitRate = options.bitRate;
        forceRestart = options.forceRestart;

        if (forceRestart) {
          context$1$0.next = 15;
          break;
        }

        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(this.stopRecordingScreen(options));

      case 12:
        result = context$1$0.sent;
        context$1$0.next = 25;
        break;

      case 15:
        if (_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          context$1$0.next = 25;
          break;
        }

        if (!(this._screenRecordingProperties.recordingProcess && this._screenRecordingProperties.recordingProcess.isRunning)) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.prev = 17;
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(this._screenRecordingProperties.recordingProcess.stop('SIGTERM', PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000));

      case 20:
        this._screenRecordingProperties.recordingProcess = null;
        context$1$0.next = 25;
        break;

      case 23:
        context$1$0.prev = 23;
        context$1$0.t0 = context$1$0['catch'](17);

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(terminateBackgroundScreenRecording(this.adb));

      case 27:
        if (!context$1$0.sent) {
          context$1$0.next = 29;
          break;
        }

        _logger2['default'].warn('There were some ' + SCREENRECORD_BINARY + ' process leftovers running ' + 'in the background. Make sure you stop screen recording each time after it is started, ' + 'otherwise the recorded media might quickly exceed all the free space on the device under test.');

      case 29:
        if (_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          context$1$0.next = 57;
          break;
        }

        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 33;
        _iterator = _getIterator(this._screenRecordingProperties.records || []);

      case 35:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 42;
          break;
        }

        record = _step.value;
        context$1$0.next = 39;
        return _regeneratorRuntime.awrap(this.adb.rimraf(record));

      case 39:
        _iteratorNormalCompletion = true;
        context$1$0.next = 35;
        break;

      case 42:
        context$1$0.next = 48;
        break;

      case 44:
        context$1$0.prev = 44;
        context$1$0.t1 = context$1$0['catch'](33);
        _didIteratorError = true;
        _iteratorError = context$1$0.t1;

      case 48:
        context$1$0.prev = 48;
        context$1$0.prev = 49;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 51:
        context$1$0.prev = 51;

        if (!_didIteratorError) {
          context$1$0.next = 54;
          break;
        }

        throw _iteratorError;

      case 54:
        return context$1$0.finish(51);

      case 55:
        return context$1$0.finish(48);

      case 56:
        this._screenRecordingProperties = null;

      case 57:
        timeout = parseFloat(timeLimit);

        if (!(isNaN(timeout) || timeout > MAX_TIME_SEC || timeout <= 0)) {
          context$1$0.next = 60;
          break;
        }

        throw new Error('The timeLimit value must be in range [1, ' + MAX_TIME_SEC + '] seconds. ' + ('The value of \'' + timeLimit + '\' has been passed instead.'));

      case 60:

        this._screenRecordingProperties = {
          startTimestamp: process.hrtime(),
          videoSize: videoSize,
          timeLimit: timeLimit,
          currentTimeLimit: timeLimit,
          bitRate: bitRate,
          bugReport: bugReport,
          records: [],
          recordingProcess: null,
          stopped: false
        };
        context$1$0.next = 63;
        return _regeneratorRuntime.awrap(scheduleScreenRecord(this.adb, this._screenRecordingProperties));

      case 63:
        return context$1$0.abrupt('return', result);

      case 64:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[17, 23], [33, 44, 48, 56], [49,, 51, 55]]);
};

/**
 * @typedef {Object} StopRecordingOptions
 *
 * @property {?string} remotePath - The path to the remote location, where the resulting video should be uploaded.
 *                                  The following protocols are supported: http/https, ftp.
 *                                  Null or empty string value (the default setting) means the content of resulting
 *                                  file should be encoded as Base64 and passed as the endpount response value.
 *                                  An exception will be thrown if the generated media file is too big to
 *                                  fit into the available process memory.
 * @property {?string} user - The name of the user for the remote authentication.
 * @property {?string} pass - The password for the remote authentication.
 * @property {?string} method - The http multipart upload method name. The 'PUT' one is used by default.
 */

/**
 * Stop recording the screen.
 * If no screen recording has been started before then the method returns an empty string.
 *
 * @param {?StopRecordingOptions} options - The available options.
 * @returns {string} Base64-encoded content of the recorded media file if 'remotePath'
 *                   parameter is falsy or an empty string.
 * @throws {Error} If there was an error while getting the name of a media file
 *                 or the file content cannot be uploaded to the remote location
 *                 or screen recording is not supported on the device under test.
 */
commands.stopRecordingScreen = function callee$0$0() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var result, tmpRoot, localRecords, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, pathOnDevice, resultFilePath, remotePath, user, pass, method;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(verifyScreenRecordIsSupported(this.adb, this.isEmulator()));

      case 2:
        if (!_lodash2['default'].isEmpty(this._screenRecordingProperties)) {
          context$1$0.next = 12;
          break;
        }

        _logger2['default'].info('Screen recording has not been previously started by Appium. There is nothing to stop');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(terminateBackgroundScreenRecording(this.adb));

      case 7:
        context$1$0.next = 11;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](4);

      case 11:
        return context$1$0.abrupt('return', '');

      case 12:

        this._screenRecordingProperties.stopped = true;

        if (!(this._screenRecordingProperties.recordingProcess && this._screenRecordingProperties.recordingProcess.isRunning)) {
          context$1$0.next = 23;
          break;
        }

        context$1$0.prev = 14;
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(this._screenRecordingProperties.recordingProcess.stop('SIGINT', PROCESS_SHUTDOWN_TIMEOUT_SEC * 1000));

      case 17:
        this._screenRecordingProperties.recordingProcess = null;
        context$1$0.next = 23;
        break;

      case 20:
        context$1$0.prev = 20;
        context$1$0.t1 = context$1$0['catch'](14);

        _logger2['default'].errorAndThrow('Unable to stop screen recording. Original error: ' + context$1$0.t1.message);

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(terminateBackgroundScreenRecording(this.adb));

      case 26:
        context$1$0.next = 30;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.t2 = context$1$0['catch'](23);

      case 30:

        if (_lodash2['default'].isEmpty(this._screenRecordingProperties.records)) {
          _logger2['default'].errorAndThrow('No screen recordings have been stored on the device so far. ' + ('Are you sure the ' + SCREENRECORD_BINARY + ' utility works as expected?'));
        }

        result = '';
        context$1$0.next = 34;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.openDir());

      case 34:
        tmpRoot = context$1$0.sent;
        context$1$0.prev = 35;
        localRecords = [];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 40;
        _iterator2 = _getIterator(this._screenRecordingProperties.records);

      case 42:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 52;
          break;
        }

        pathOnDevice = _step2.value;

        localRecords.push(_path2['default'].resolve(tmpRoot, _path2['default'].posix.basename(pathOnDevice)));
        context$1$0.next = 47;
        return _regeneratorRuntime.awrap(this.adb.pull(pathOnDevice, _lodash2['default'].last(localRecords)));

      case 47:
        context$1$0.next = 49;
        return _regeneratorRuntime.awrap(this.adb.rimraf(pathOnDevice));

      case 49:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 42;
        break;

      case 52:
        context$1$0.next = 58;
        break;

      case 54:
        context$1$0.prev = 54;
        context$1$0.t3 = context$1$0['catch'](40);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t3;

      case 58:
        context$1$0.prev = 58;
        context$1$0.prev = 59;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 61:
        context$1$0.prev = 61;

        if (!_didIteratorError2) {
          context$1$0.next = 64;
          break;
        }

        throw _iteratorError2;

      case 64:
        return context$1$0.finish(61);

      case 65:
        return context$1$0.finish(58);

      case 66:
        resultFilePath = _lodash2['default'].last(localRecords);

        if (!(localRecords.length > 1)) {
          context$1$0.next = 78;
          break;
        }

        _logger2['default'].info('Got ' + localRecords.length + ' screen recordings. Trying to merge them');
        context$1$0.prev = 69;
        context$1$0.next = 72;
        return _regeneratorRuntime.awrap(mergeScreenRecords(localRecords));

      case 72:
        resultFilePath = context$1$0.sent;
        context$1$0.next = 78;
        break;

      case 75:
        context$1$0.prev = 75;
        context$1$0.t4 = context$1$0['catch'](69);

        _logger2['default'].warn('Cannot merge the recorded files. The most recent screen recording is going to be returned as the result. ' + ('Original error: ' + context$1$0.t4.message));

      case 78:
        remotePath = options.remotePath;
        user = options.user;
        pass = options.pass;
        method = options.method;
        context$1$0.next = 84;
        return _regeneratorRuntime.awrap(uploadRecordedMedia(this.adb, resultFilePath, remotePath, { user: user, pass: pass, method: method }));

      case 84:
        result = context$1$0.sent;

      case 85:
        context$1$0.prev = 85;
        context$1$0.next = 88;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(tmpRoot));

      case 88:
        this._screenRecordingProperties = null;
        return context$1$0.finish(85);

      case 90:
        return context$1$0.abrupt('return', result);

      case 91:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 9], [14, 20], [23, 28], [35,, 85, 90], [40, 54, 58, 66], [59,, 61, 65], [69, 75]]);
};

_Object$assign(extensions, commands);
exports.commands = commands;
exports['default'] = extensions;
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9yZWNvcmRzY3JlZW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztzQkFBYyxRQUFROzs7O21CQUNOLElBQUk7Ozs7bUJBQ0osS0FBSzs7Ozt3QkFDWSxVQUFVOzs2QkFDSSxnQkFBZ0I7O3NCQUMvQyxXQUFXOzs7OzRCQUNOLGNBQWM7O29CQUNsQixNQUFNOzs7O2tCQUNSLElBQUk7Ozs7QUFHbkIsSUFBSSxRQUFRLEdBQUcsRUFBRTtJQUFFLFVBQVUsR0FBRyxFQUFFLENBQUM7O0FBRW5DLElBQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQztBQUN4QixJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFDM0IsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sWUFBWSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDN0IsSUFBTSwwQkFBMEIsR0FBRyxzQkFBc0IsQ0FBQztBQUMxRCxJQUFNLDRCQUE0QixHQUFHLENBQUMsQ0FBQztBQUN2QyxJQUFNLG1CQUFtQixHQUFHLGNBQWMsQ0FBQztBQUMzQyxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUM7QUFDM0IsSUFBTSxzQkFBc0IsR0FBRyxFQUFFLENBQUM7QUFDbEMsSUFBTSxhQUFhLGVBQVksc0JBQU8sU0FBUyxFQUFFLEdBQUcsTUFBTSxHQUFHLEVBQUUsQ0FBQSxBQUFFLENBQUM7O0FBRWxFLFNBQWUsbUJBQW1CLENBQUUsR0FBRyxFQUFFLFNBQVM7TUFBRSxVQUFVLHlEQUFHLElBQUk7TUFBRSxhQUFhLHlEQUFHLEVBQUU7O1lBQ2hGLElBQUksRUFHSCxjQUFjLEVBVWhCLFNBQVMsRUFDWCxPQUFPLEVBQ0osSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNOzs7Ozs7eUNBZkosa0JBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQzs7OztBQUFoQyxZQUFJLFFBQUosSUFBSTs7QUFDWCw0QkFBSSxLQUFLLG9EQUFrRCxvQkFBSyxv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QzNCLFFBQVEsR0FBUixRQUFRO3FCQUNGLFVBQVUiLCJmaWxlIjoibGliL2NvbW1hbmRzL3JlY29yZHNjcmVlbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgX2ZzIGZyb20gJ2ZzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyB1dGlsLCBmcywgbmV0LCB0ZW1wRGlyLCBzeXN0ZW0gfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHY4IGZyb20gJ3Y4JztcblxuXG5sZXQgY29tbWFuZHMgPSB7fSwgZXh0ZW5zaW9ucyA9IHt9O1xuXG5jb25zdCBSRVRSWV9QQVVTRSA9IDMwMDtcbmNvbnN0IFJFVFJZX1RJTUVPVVQgPSA1MDAwO1xuY29uc3QgTUFYX1JFQ09SRElOR19USU1FX1NFQyA9IDYwICogMztcbmNvbnN0IE1BWF9USU1FX1NFQyA9IDYwICogMzA7XG5jb25zdCBERUZBVUxUX1JFQ09SRElOR19USU1FX1NFQyA9IE1BWF9SRUNPUkRJTkdfVElNRV9TRUM7XG5jb25zdCBQUk9DRVNTX1NIVVRET1dOX1RJTUVPVVRfU0VDID0gNTtcbmNvbnN0IFNDUkVFTlJFQ09SRF9CSU5BUlkgPSAnc2NyZWVucmVjb3JkJztcbmNvbnN0IERFRkFVTFRfRVhUID0gJy5tcDQnO1xuY29uc3QgTUlOX0VNVUxBVE9SX0FQSV9MRVZFTCA9IDI3O1xuY29uc3QgRkZNUEVHX0JJTkFSWSA9IGBmZm1wZWcke3N5c3RlbS5pc1dpbmRvd3MoKSA/ICcuZXhlJyA6ICcnfWA7XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZFJlY29yZGVkTWVkaWEgKGFkYiwgbG9jYWxGaWxlLCByZW1vdGVQYXRoID0gbnVsbCwgdXBsb2FkT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtzaXplfSA9IGF3YWl0IGZzLnN0YXQobG9jYWxGaWxlKTtcbiAgbG9nLmRlYnVnKGBUaGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIHNjcmVlbiByZWNvcmRpbmcgaXMgJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfWApO1xuICBpZiAoXy5pc0VtcHR5KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3QgbWF4TWVtb3J5TGltaXQgPSB2OC5nZXRIZWFwU3RhdGlzdGljcygpLnRvdGFsX2F2YWlsYWJsZV9zaXplIC8gMjtcbiAgICBpZiAoc2l6ZSA+PSBtYXhNZW1vcnlMaW1pdCkge1xuICAgICAgbG9nLmluZm8oYFRoZSBmaWxlIG1pZ2h0IGJlIHRvbyBsYXJnZSB0byBmaXQgaW50byB0aGUgcHJvY2VzcyBtZW1vcnkgYCArXG4gICAgICAgIGAoJHt1dGlsLnRvUmVhZGFibGVTaXplU3RyaW5nKHNpemUpfSA+PSAke3V0aWwudG9SZWFkYWJsZVNpemVTdHJpbmcobWF4TWVtb3J5TGltaXQpfSkuIGAgK1xuICAgICAgICBgUHJvdmlkZSBhIGxpbmsgdG8gYSByZW1vdGUgd3JpdGFibGUgbG9jYXRpb24gZm9yIHZpZGVvIHVwbG9hZCBgICtcbiAgICAgICAgYChodHRwKHMpIGFuZCBmdHAgcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQpIGlmIHlvdSBleHBlcmllbmNlIE91dCBPZiBNZW1vcnkgZXJyb3JzYCk7XG4gICAgfVxuICAgIHJldHVybiAoYXdhaXQgZnMucmVhZEZpbGUobG9jYWxGaWxlKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgcmVtb3RlVXJsID0gdXJsLnBhcnNlKHJlbW90ZVBhdGgpO1xuICBsZXQgb3B0aW9ucyA9IHt9O1xuICBjb25zdCB7dXNlciwgcGFzcywgbWV0aG9kfSA9IHVwbG9hZE9wdGlvbnM7XG4gIGlmIChyZW1vdGVVcmwucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHVybDogcmVtb3RlVXJsLmhyZWYsXG4gICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUFVUJyxcbiAgICAgIG11bHRpcGFydDogW3sgYm9keTogX2ZzLmNyZWF0ZVJlYWRTdHJlYW0obG9jYWxGaWxlKSB9XSxcbiAgICB9O1xuICAgIGlmICh1c2VyICYmIHBhc3MpIHtcbiAgICAgIG9wdGlvbnMuYXV0aCA9IHt1c2VyLCBwYXNzfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVtb3RlVXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoJ2Z0cCcpKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGhvc3Q6IHJlbW90ZVVybC5ob3N0bmFtZSxcbiAgICAgIHBvcnQ6IHJlbW90ZVVybC5wb3J0IHx8IDIxLFxuICAgIH07XG4gICAgaWYgKHVzZXIgJiYgcGFzcykge1xuICAgICAgb3B0aW9ucy51c2VyID0gdXNlcjtcbiAgICAgIG9wdGlvbnMucGFzcyA9IHBhc3M7XG4gICAgfVxuICB9XG4gIGF3YWl0IG5ldC51cGxvYWRGaWxlKGxvY2FsRmlsZSwgcmVtb3RlUGF0aCwgb3B0aW9ucyk7XG4gIHJldHVybiAnJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2NyZWVuUmVjb3JkSXNTdXBwb3J0ZWQgKGFkYiwgaXNFbXVsYXRvcikge1xuICBjb25zdCBhcGlMZXZlbCA9IGF3YWl0IGFkYi5nZXRBcGlMZXZlbCgpO1xuICBpZiAoaXNFbXVsYXRvciAmJiBhcGlMZXZlbCA8IE1JTl9FTVVMQVRPUl9BUElfTEVWRUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNjcmVlbiByZWNvcmRpbmcgZG9lcyBub3Qgd29yayBvbiBlbXVsYXRvcnMgcnVubmluZyBBbmRyb2lkIEFQSSBsZXZlbCBsZXNzIHRoYW4gJHtNSU5fRU1VTEFUT1JfQVBJX0xFVkVMfWApO1xuICB9XG4gIGlmIChhcGlMZXZlbCA8IDE5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTY3JlZW4gcmVjb3JkaW5nIG5vdCBhdmFpbGFibGUgb24gQVBJIExldmVsICR7YXBpTGV2ZWx9LiBNaW5pbXVtIEFQSSBMZXZlbCBpcyAxOS5gKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzY2hlZHVsZVNjcmVlblJlY29yZCAoYWRiLCByZWNvcmRpbmdQcm9wZXJ0aWVzKSB7XG4gIGlmIChyZWNvcmRpbmdQcm9wZXJ0aWVzLnN0b3BwZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7XG4gICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgdmlkZW9TaXplLFxuICAgIGJpdFJhdGUsXG4gICAgdGltZUxpbWl0LFxuICAgIGJ1Z1JlcG9ydCxcbiAgfSA9IHJlY29yZGluZ1Byb3BlcnRpZXM7XG5cbiAgbGV0IGN1cnJlbnRUaW1lTGltaXQgPSBNQVhfUkVDT1JESU5HX1RJTUVfU0VDO1xuICBpZiAodXRpbC5oYXNWYWx1ZShyZWNvcmRpbmdQcm9wZXJ0aWVzLmN1cnJlbnRUaW1lTGltaXQpKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWVMaW1pdEludCA9IHBhcnNlSW50KHJlY29yZGluZ1Byb3BlcnRpZXMuY3VycmVudFRpbWVMaW1pdCwgMTApO1xuICAgIGlmICghaXNOYU4oY3VycmVudFRpbWVMaW1pdEludCkgJiYgY3VycmVudFRpbWVMaW1pdEludCA8IE1BWF9SRUNPUkRJTkdfVElNRV9TRUMpIHtcbiAgICAgIGN1cnJlbnRUaW1lTGltaXQgPSBjdXJyZW50VGltZUxpbWl0SW50O1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXRoT25EZXZpY2UgPSBgL3NkY2FyZC8ke01hdGguZmxvb3IobmV3IERhdGUoKSl9JHtERUZBVUxUX0VYVH1gO1xuICBjb25zdCByZWNvcmRpbmdQcm9jID0gYWRiLnNjcmVlbnJlY29yZChwYXRoT25EZXZpY2UsIHtcbiAgICB2aWRlb1NpemUsXG4gICAgYml0UmF0ZSxcbiAgICB0aW1lTGltaXQ6IGN1cnJlbnRUaW1lTGltaXQsXG4gICAgYnVnUmVwb3J0LFxuICB9KTtcblxuICByZWNvcmRpbmdQcm9jLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgaWYgKHJlY29yZGluZ1Byb3BlcnRpZXMuc3RvcHBlZCB8fCAhdXRpbC5oYXNWYWx1ZSh0aW1lTGltaXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnREdXJhdGlvbiA9IHByb2Nlc3MuaHJ0aW1lKHN0YXJ0VGltZXN0YW1wKVswXTtcbiAgICBsb2cuZGVidWcoYFRoZSBvdmVyYWxsIHNjcmVlbiByZWNvcmRpbmcgZHVyYXRpb24gaXMgJHtjdXJyZW50RHVyYXRpb259cyBzbyBmYXJgKTtcbiAgICBjb25zdCB0aW1lTGltaXRJbnQgPSBwYXJzZUludCh0aW1lTGltaXQsIDEwKTtcbiAgICBpZiAoaXNOYU4odGltZUxpbWl0SW50KSB8fCBjdXJyZW50RHVyYXRpb24gPj0gdGltZUxpbWl0SW50KSB7XG4gICAgICBsb2cuZGVidWcoJ1RoZXJlIGlzIG5vIG5lZWQgdG8gc3RhcnQgdGhlIG5leHQgcmVjb3JkaW5nIGNodW5rJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVjb3JkaW5nUHJvcGVydGllcy5jdXJyZW50VGltZUxpbWl0ID0gdGltZUxpbWl0SW50IC0gY3VycmVudER1cmF0aW9uO1xuICAgIGNvbnN0IGNodW5rRHVyYXRpb24gPSByZWNvcmRpbmdQcm9wZXJ0aWVzLmN1cnJlbnRUaW1lTGltaXQgPCBNQVhfUkVDT1JESU5HX1RJTUVfU0VDXG4gICAgICA/IHJlY29yZGluZ1Byb3BlcnRpZXMuY3VycmVudFRpbWVMaW1pdFxuICAgICAgOiBNQVhfUkVDT1JESU5HX1RJTUVfU0VDO1xuICAgIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgdGhlIG5leHQgJHtjaHVua0R1cmF0aW9ufXMtY2h1bmsgYCArXG4gICAgICBgb2Ygc2NyZWVuIHJlY29yZGluZyBpbiBvcmRlciB0byBhY2hpZXZlICR7dGltZUxpbWl0SW50fXMgdG90YWwgZHVyYXRpb25gKTtcbiAgICBzY2hlZHVsZVNjcmVlblJlY29yZChhZGIsIHJlY29yZGluZ1Byb3BlcnRpZXMpXG4gICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgbG9nLmVycm9yKGUuc3RhY2spO1xuICAgICAgICByZWNvcmRpbmdQcm9wZXJ0aWVzLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gIH0pO1xuXG4gIGF3YWl0IHJlY29yZGluZ1Byb2Muc3RhcnQoMCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiBhd2FpdCBhZGIuZmlsZUV4aXN0cyhwYXRoT25EZXZpY2UpLFxuICAgICAge3dhaXRNczogUkVUUllfVElNRU9VVCwgaW50ZXJ2YWxNczogUkVUUllfUEFVU0V9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGV4cGVjdGVkIHNjcmVlbiByZWNvcmQgZmlsZSAnJHtwYXRoT25EZXZpY2V9JyBkb2VzIG5vdCBleGlzdCBhZnRlciAke1JFVFJZX1RJTUVPVVR9bXNgKTtcbiAgfVxuXG4gIHJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3Jkcy5wdXNoKHBhdGhPbkRldmljZSk7XG4gIHJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2VzcyA9IHJlY29yZGluZ1Byb2M7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1lcmdlU2NyZWVuUmVjb3JkcyAobWVkaWFGaWxlcykge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndoaWNoKEZGTVBFR19CSU5BUlkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke0ZGTVBFR19CSU5BUll9IHV0aWxpdHkgaXMgbm90IGF2YWlsYWJsZSBpbiBQQVRILiBQbGVhc2UgaW5zdGFsbCBpdCBmcm9tIGh0dHBzOi8vd3d3LmZmbXBlZy5vcmcvYCk7XG4gIH1cbiAgY29uc3QgY29uZmlnQ29udGVudCA9IG1lZGlhRmlsZXNcbiAgICAubWFwKCh4KSA9PiBgZmlsZSAnJHt4fSdgKVxuICAgIC5qb2luKCdcXG4nKTtcbiAgY29uc3QgY29uZmlnRmlsZSA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUobWVkaWFGaWxlc1swXSksICdjb25maWcudHh0Jyk7XG4gIGF3YWl0IGZzLndyaXRlRmlsZShjb25maWdGaWxlLCBjb25maWdDb250ZW50LCAndXRmOCcpO1xuICBsb2cuZGVidWcoYEdlbmVyYXRlZCBmZm1wZWcgbWVyZ2luZyBjb25maWcgJyR7Y29uZmlnRmlsZX0nIHdpdGggaXRlbXM6XFxuJHtjb25maWdDb250ZW50fWApO1xuICBjb25zdCByZXN1bHQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKG1lZGlhRmlsZXNbMF0pLCBgbWVyZ2VfJHtNYXRoLmZsb29yKG5ldyBEYXRlKCkpfSR7REVGQVVMVF9FWFR9YCk7XG4gIGNvbnN0IGFyZ3MgPSBbJy1zYWZlJywgJzAnLCAnLWYnLCAnY29uY2F0JywgJy1pJywgY29uZmlnRmlsZSwgJy1jJywgJ2NvcHknLCByZXN1bHRdO1xuICBsb2cuaW5mbyhgSW5pdGlhdGluZyBzY3JlZW4gcmVjb3JkcyBtZXJnaW5nIHVzaW5nIHRoZSBjb21tYW5kICcke0ZGTVBFR19CSU5BUll9ICR7YXJncy5qb2luKCcgJyl9J2ApO1xuICBhd2FpdCBleGVjKEZGTVBFR19CSU5BUlksIGFyZ3MpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5hc3luYyBmdW5jdGlvbiB0ZXJtaW5hdGVCYWNrZ3JvdW5kU2NyZWVuUmVjb3JkaW5nIChhZGIpIHtcbiAgY29uc3QgcGlkcyA9IChhd2FpdCBhZGIuZ2V0UElEc0J5TmFtZShTQ1JFRU5SRUNPUkRfQklOQVJZKSlcbiAgICAubWFwKChwKSA9PiBgJHtwfWApO1xuICBpZiAoXy5pc0VtcHR5KHBpZHMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBhZGIuc2hlbGwoWydraWxsJywgLi4ucGlkc10pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBzdG9wIHRoZSBiYWNrZ3JvdW5kIHNjcmVlbiByZWNvcmRpbmc6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXJ0UmVjb3JkaW5nT3B0aW9uc1xuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIHRoZSByZW1vdGUgbG9jYXRpb24sIHdoZXJlIHRoZSBjYXB0dXJlZCB2aWRlbyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHByb3RvY29scyBhcmUgc3VwcG9ydGVkOiBodHRwL2h0dHBzLCBmdHAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdWxsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZSAodGhlIGRlZmF1bHQgc2V0dGluZykgbWVhbnMgdGhlIGNvbnRlbnQgb2YgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHNob3VsZCBiZSBlbmNvZGVkIGFzIEJhc2U2NCBhbmQgcGFzc2VkIGFzIHRoZSBlbmRwb3VudCByZXNwb25zZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBpZiB0aGUgZ2VuZXJhdGVkIG1lZGlhIGZpbGUgaXMgdG9vIGJpZyB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IGludG8gdGhlIGF2YWlsYWJsZSBwcm9jZXNzIG1lbW9yeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb3B0aW9uIG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGVyZSBpcyBzY3JlZW4gcmVjb3JkaW5nIHByb2Nlc3MgaW4gcHJvZ3JlZXNzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYGZvcmNlUmVzdGFydGAgcGFyYW1ldGVyIGlzIG5vdCBzZXQgdG8gYHRydWVgLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB1c2VyIC0gVGhlIG5hbWUgb2YgdGhlIHVzZXIgZm9yIHRoZSByZW1vdGUgYXV0aGVudGljYXRpb24uIE9ubHkgd29ya3MgaWYgYHJlbW90ZVBhdGhgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwYXNzIC0gVGhlIHBhc3N3b3JkIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLiBPbmx5IHdvcmtzIGlmIGByZW1vdGVQYXRoYCBpcyBwcm92aWRlZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbWV0aG9kIC0gVGhlIGh0dHAgbXVsdGlwYXJ0IHVwbG9hZCBtZXRob2QgbmFtZS4gVGhlICdQVVQnIG9uZSBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgd29ya3MgaWYgYHJlbW90ZVBhdGhgIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSB2aWRlb1NpemUgLSBUaGUgZm9ybWF0IGlzIHdpZHRoeGhlaWdodC5cbiAqICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGhlIGRldmljZSdzIG5hdGl2ZSBkaXNwbGF5IHJlc29sdXRpb24gKGlmIHN1cHBvcnRlZCksXG4gKiAgICAgICAgICAgICAgICAgIDEyODB4NzIwIGlmIG5vdC4gRm9yIGJlc3QgcmVzdWx0cyxcbiAqICAgICAgICAgICAgICAgICAgdXNlIGEgc2l6ZSBzdXBwb3J0ZWQgYnkgeW91ciBkZXZpY2UncyBBZHZhbmNlZCBWaWRlbyBDb2RpbmcgKEFWQykgZW5jb2Rlci5cbiAqICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIFwiMTI4MHg3MjBcIlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gYnVnUmVwb3J0IC0gU2V0IGl0IHRvIGB0cnVlYCBpbiBvcmRlciB0byBkaXNwbGF5IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb24gdGhlIHZpZGVvIG92ZXJsYXksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNoIGFzIGEgdGltZXN0YW1wLCB0aGF0IGlzIGhlbHBmdWwgaW4gdmlkZW9zIGNhcHR1cmVkIHRvIGlsbHVzdHJhdGUgYnVncy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHNpbmNlIEFQSSBsZXZlbCAyNyAoQW5kcm9pZCBQKS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ3xudW1iZXJ9IHRpbWVMaW1pdCAtIFRoZSBtYXhpbXVtIHJlY29yZGluZyB0aW1lLCBpbiBzZWNvbmRzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxODAgKDMgbWludXRlcykuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZSBpcyAxODAwICgzMCBtaW51dGVzKS4gSWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTgwIHRoZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhbGdvcml0aG0gd2lsbCB0cnkgdG8gc2NoZWR1bGUgbXVsdGlwbGUgc2NyZWVuIHJlY29yZGluZyBjaHVua3MgYW5kIG1lcmdlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nIHZpZGVvcyBpbnRvIGEgc2luZ2xlIG1lZGlhIGZpbGUgdXNpbmcgYGZmbXBlZ2AgdXRpbGl0eS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRoZSB1dGlsaXR5IGlzIG5vdCBhdmFpbGFibGUgaW4gUEFUSCB0aGVuIHRoZSBtb3N0IHJlY2VudCBzY3JlZW4gcmVjb3JkaW5nIGNodW5rIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnb2luZyB0byBiZSByZXR1cm5lZC5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ3xudW1iZXJ9IGJpdFJhdGUgLSBUaGUgdmlkZW8gYml0IHJhdGUgZm9yIHRoZSB2aWRlbywgaW4gbWVnYWJpdHMgcGVyIHNlY29uZC5cbiAqICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDQuIFlvdSBjYW4gaW5jcmVhc2UgdGhlIGJpdCByYXRlIHRvIGltcHJvdmUgdmlkZW8gcXVhbGl0eSxcbiAqICAgICAgICAgICAgICAgIGJ1dCBkb2luZyBzbyByZXN1bHRzIGluIGxhcmdlciBtb3ZpZSBmaWxlcy5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGZvcmNlUmVzdGFydCAtIFdoZXRoZXIgdG8gdHJ5IHRvIGNhdGNoIGFuZCB1cGxvYWQvcmV0dXJuIHRoZSBjdXJyZW50bHkgcnVubmluZyBzY3JlZW4gcmVjb3JkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYGZhbHNlYCwgdGhlIGRlZmF1bHQgc2V0dGluZykgb3IgaWdub3JlIHRoZSByZXN1bHQgb2YgaXQgYW5kIHN0YXJ0IGEgbmV3IHJlY29yZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlbHkgKGB0cnVlYCkuXG4gKi9cblxuLyoqXG4gKiBSZWNvcmQgdGhlIGRpc3BsYXkgb2YgYSByZWFsIGRldmljZXMgcnVubmluZyBBbmRyb2lkIDQuNCAoQVBJIGxldmVsIDE5KSBhbmQgaGlnaGVyLlxuICogRW11bGF0b3JzIGFyZSBzdXBwb3J0ZWQgc2luY2UgQVBJIGxldmVsIDI3IChBbmRyb2lkIFApLlxuICogSXQgcmVjb3JkcyBzY3JlZW4gYWN0aXZpdHkgdG8gYW4gTVBFRy00IGZpbGUuIEF1ZGlvIGlzIG5vdCByZWNvcmRlZCB3aXRoIHRoZSB2aWRlbyBmaWxlLlxuICogSWYgc2NyZWVuIHJlY29yZGluZyBoYXMgYmVlbiBhbHJlYWR5IHN0YXJ0ZWQgdGhlbiB0aGUgY29tbWFuZCB3aWxsIHN0b3AgaXQgZm9yY2VmdWxseSBhbmQgc3RhcnQgYSBuZXcgb25lLlxuICogVGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmlkZW8gZmlsZSB3aWxsIGJlIGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIHs/U3RhcnRSZWNvcmRpbmdPcHRpb25zfSBvcHRpb25zIC0gVGhlIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgY29udGVudCBvZiB0aGUgcmVjb3JkZWQgbWVkaWEgZmlsZSBpZlxuICogICAgICAgICAgICAgICAgICAgYW55IHNjcmVlbiByZWNvcmRpbmcgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IElmIHNjcmVlbiByZWNvcmRpbmcgaGFzIGZhaWxlZCB0byBzdGFydCBvciBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqL1xuY29tbWFuZHMuc3RhcnRSZWNvcmRpbmdTY3JlZW4gPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIGF3YWl0IHZlcmlmeVNjcmVlblJlY29yZElzU3VwcG9ydGVkKHRoaXMuYWRiLCB0aGlzLmlzRW11bGF0b3IoKSk7XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBjb25zdCB7dmlkZW9TaXplLCB0aW1lTGltaXQ9REVGQVVMVF9SRUNPUkRJTkdfVElNRV9TRUMsIGJ1Z1JlcG9ydCwgYml0UmF0ZSwgZm9yY2VSZXN0YXJ0fSA9IG9wdGlvbnM7XG4gIGlmICghZm9yY2VSZXN0YXJ0KSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zdG9wUmVjb3JkaW5nU2NyZWVuKG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKCFfLmlzRW1wdHkodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcykpIHtcbiAgICBpZiAodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRpbmdQcm9jZXNzICYmIHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2Vzcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2Vzcy5zdG9wKCdTSUdURVJNJywgUFJPQ0VTU19TSFVURE9XTl9USU1FT1VUX1NFQyAqIDEwMDApO1xuICAgICAgICB0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzLnJlY29yZGluZ1Byb2Nlc3MgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgIH1cbiAgfVxuXG4gIGlmIChhd2FpdCB0ZXJtaW5hdGVCYWNrZ3JvdW5kU2NyZWVuUmVjb3JkaW5nKHRoaXMuYWRiKSkge1xuICAgIGxvZy53YXJuKGBUaGVyZSB3ZXJlIHNvbWUgJHtTQ1JFRU5SRUNPUkRfQklOQVJZfSBwcm9jZXNzIGxlZnRvdmVycyBydW5uaW5nIGAgK1xuICAgICAgYGluIHRoZSBiYWNrZ3JvdW5kLiBNYWtlIHN1cmUgeW91IHN0b3Agc2NyZWVuIHJlY29yZGluZyBlYWNoIHRpbWUgYWZ0ZXIgaXQgaXMgc3RhcnRlZCwgYCArXG4gICAgICBgb3RoZXJ3aXNlIHRoZSByZWNvcmRlZCBtZWRpYSBtaWdodCBxdWlja2x5IGV4Y2VlZCBhbGwgdGhlIGZyZWUgc3BhY2Ugb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LmApO1xuICB9XG5cbiAgaWYgKCFfLmlzRW1wdHkodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcykpIHtcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiAodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRzIHx8IFtdKSkge1xuICAgICAgYXdhaXQgdGhpcy5hZGIucmltcmFmKHJlY29yZCk7XG4gICAgfVxuICAgIHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgdGltZW91dCA9IHBhcnNlRmxvYXQodGltZUxpbWl0KTtcbiAgaWYgKGlzTmFOKHRpbWVvdXQpIHx8IHRpbWVvdXQgPiBNQVhfVElNRV9TRUMgfHwgdGltZW91dCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdGltZUxpbWl0IHZhbHVlIG11c3QgYmUgaW4gcmFuZ2UgWzEsICR7TUFYX1RJTUVfU0VDfV0gc2Vjb25kcy4gYCArXG4gICAgICBgVGhlIHZhbHVlIG9mICcke3RpbWVMaW1pdH0nIGhhcyBiZWVuIHBhc3NlZCBpbnN0ZWFkLmApO1xuICB9XG5cbiAgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcyA9IHtcbiAgICBzdGFydFRpbWVzdGFtcDogcHJvY2Vzcy5ocnRpbWUoKSxcbiAgICB2aWRlb1NpemUsXG4gICAgdGltZUxpbWl0LFxuICAgIGN1cnJlbnRUaW1lTGltaXQ6IHRpbWVMaW1pdCxcbiAgICBiaXRSYXRlLFxuICAgIGJ1Z1JlcG9ydCxcbiAgICByZWNvcmRzOiBbXSxcbiAgICByZWNvcmRpbmdQcm9jZXNzOiBudWxsLFxuICAgIHN0b3BwZWQ6IGZhbHNlLFxuICB9O1xuICBhd2FpdCBzY2hlZHVsZVNjcmVlblJlY29yZCh0aGlzLmFkYiwgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcyk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0b3BSZWNvcmRpbmdPcHRpb25zXG4gKlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gdGhlIHJlbW90ZSBsb2NhdGlvbiwgd2hlcmUgdGhlIHJlc3VsdGluZyB2aWRlbyBzaG91bGQgYmUgdXBsb2FkZWQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHByb3RvY29scyBhcmUgc3VwcG9ydGVkOiBodHRwL2h0dHBzLCBmdHAuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdWxsIG9yIGVtcHR5IHN0cmluZyB2YWx1ZSAodGhlIGRlZmF1bHQgc2V0dGluZykgbWVhbnMgdGhlIGNvbnRlbnQgb2YgcmVzdWx0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlIHNob3VsZCBiZSBlbmNvZGVkIGFzIEJhc2U2NCBhbmQgcGFzc2VkIGFzIHRoZSBlbmRwb3VudCByZXNwb25zZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biBpZiB0aGUgZ2VuZXJhdGVkIG1lZGlhIGZpbGUgaXMgdG9vIGJpZyB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml0IGludG8gdGhlIGF2YWlsYWJsZSBwcm9jZXNzIG1lbW9yeS5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBwYXNzIC0gVGhlIHBhc3N3b3JkIGZvciB0aGUgcmVtb3RlIGF1dGhlbnRpY2F0aW9uLlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBtZXRob2QgLSBUaGUgaHR0cCBtdWx0aXBhcnQgdXBsb2FkIG1ldGhvZCBuYW1lLiBUaGUgJ1BVVCcgb25lIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqL1xuXG4vKipcbiAqIFN0b3AgcmVjb3JkaW5nIHRoZSBzY3JlZW4uXG4gKiBJZiBubyBzY3JlZW4gcmVjb3JkaW5nIGhhcyBiZWVuIHN0YXJ0ZWQgYmVmb3JlIHRoZW4gdGhlIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gez9TdG9wUmVjb3JkaW5nT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NC1lbmNvZGVkIGNvbnRlbnQgb2YgdGhlIHJlY29yZGVkIG1lZGlhIGZpbGUgaWYgJ3JlbW90ZVBhdGgnXG4gKiAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgaXMgZmFsc3kgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBuYW1lIG9mIGEgbWVkaWEgZmlsZVxuICogICAgICAgICAgICAgICAgIG9yIHRoZSBmaWxlIGNvbnRlbnQgY2Fubm90IGJlIHVwbG9hZGVkIHRvIHRoZSByZW1vdGUgbG9jYXRpb25cbiAqICAgICAgICAgICAgICAgICBvciBzY3JlZW4gcmVjb3JkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICovXG5jb21tYW5kcy5zdG9wUmVjb3JkaW5nU2NyZWVuID0gYXN5bmMgZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuICBhd2FpdCB2ZXJpZnlTY3JlZW5SZWNvcmRJc1N1cHBvcnRlZCh0aGlzLmFkYiwgdGhpcy5pc0VtdWxhdG9yKCkpO1xuXG4gIGlmIChfLmlzRW1wdHkodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcykpIHtcbiAgICBsb2cuaW5mbyhgU2NyZWVuIHJlY29yZGluZyBoYXMgbm90IGJlZW4gcHJldmlvdXNseSBzdGFydGVkIGJ5IEFwcGl1bS4gVGhlcmUgaXMgbm90aGluZyB0byBzdG9wYCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRlcm1pbmF0ZUJhY2tncm91bmRTY3JlZW5SZWNvcmRpbmcodGhpcy5hZGIpO1xuICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzLnN0b3BwZWQgPSB0cnVlO1xuICBpZiAodGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRpbmdQcm9jZXNzICYmIHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2Vzcy5pc1J1bm5pbmcpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRpbmdQcm9jZXNzLnN0b3AoJ1NJR0lOVCcsIFBST0NFU1NfU0hVVERPV05fVElNRU9VVF9TRUMgKiAxMDAwKTtcbiAgICAgIHRoaXMuX3NjcmVlblJlY29yZGluZ1Byb3BlcnRpZXMucmVjb3JkaW5nUHJvY2VzcyA9IG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFVuYWJsZSB0byBzdG9wIHNjcmVlbiByZWNvcmRpbmcuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IHRlcm1pbmF0ZUJhY2tncm91bmRTY3JlZW5SZWNvcmRpbmcodGhpcy5hZGIpO1xuICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgaWYgKF8uaXNFbXB0eSh0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzLnJlY29yZHMpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYE5vIHNjcmVlbiByZWNvcmRpbmdzIGhhdmUgYmVlbiBzdG9yZWQgb24gdGhlIGRldmljZSBzbyBmYXIuIGAgK1xuICAgICAgYEFyZSB5b3Ugc3VyZSB0aGUgJHtTQ1JFRU5SRUNPUkRfQklOQVJZfSB1dGlsaXR5IHdvcmtzIGFzIGV4cGVjdGVkP2ApO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgbG9jYWxSZWNvcmRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXRoT25EZXZpY2Ugb2YgdGhpcy5fc2NyZWVuUmVjb3JkaW5nUHJvcGVydGllcy5yZWNvcmRzKSB7XG4gICAgICBsb2NhbFJlY29yZHMucHVzaChwYXRoLnJlc29sdmUodG1wUm9vdCwgcGF0aC5wb3NpeC5iYXNlbmFtZShwYXRoT25EZXZpY2UpKSk7XG4gICAgICBhd2FpdCB0aGlzLmFkYi5wdWxsKHBhdGhPbkRldmljZSwgXy5sYXN0KGxvY2FsUmVjb3JkcykpO1xuICAgICAgYXdhaXQgdGhpcy5hZGIucmltcmFmKHBhdGhPbkRldmljZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHRGaWxlUGF0aCA9IF8ubGFzdChsb2NhbFJlY29yZHMpO1xuICAgIGlmIChsb2NhbFJlY29yZHMubGVuZ3RoID4gMSkge1xuICAgICAgbG9nLmluZm8oYEdvdCAke2xvY2FsUmVjb3Jkcy5sZW5ndGh9IHNjcmVlbiByZWNvcmRpbmdzLiBUcnlpbmcgdG8gbWVyZ2UgdGhlbWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0RmlsZVBhdGggPSBhd2FpdCBtZXJnZVNjcmVlblJlY29yZHMobG9jYWxSZWNvcmRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLndhcm4oYENhbm5vdCBtZXJnZSB0aGUgcmVjb3JkZWQgZmlsZXMuIFRoZSBtb3N0IHJlY2VudCBzY3JlZW4gcmVjb3JkaW5nIGlzIGdvaW5nIHRvIGJlIHJldHVybmVkIGFzIHRoZSByZXN1bHQuIGAgK1xuICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtyZW1vdGVQYXRoLCB1c2VyLCBwYXNzLCBtZXRob2R9ID0gb3B0aW9ucztcbiAgICByZXN1bHQgPSBhd2FpdCB1cGxvYWRSZWNvcmRlZE1lZGlhKHRoaXMuYWRiLCByZXN1bHRGaWxlUGF0aCwgcmVtb3RlUGF0aCwge3VzZXIsIHBhc3MsIG1ldGhvZH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBSb290KTtcbiAgICB0aGlzLl9zY3JlZW5SZWNvcmRpbmdQcm9wZXJ0aWVzID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5PYmplY3QuYXNzaWduKGV4dGVuc2lvbnMsIGNvbW1hbmRzKTtcbmV4cG9ydCB7IGNvbW1hbmRzIH07XG5leHBvcnQgZGVmYXVsdCBleHRlbnNpb25zO1xuIl0sInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
