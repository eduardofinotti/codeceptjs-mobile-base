/* eslint-disable promise/prefer-await-to-callbacks */

'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _child_process = require('child_process');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _through = require('through');

var _through2 = _interopRequireDefault(_through);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _shellQuote = require('shell-quote');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var EventEmitter = _events2['default'].EventEmitter;

var SubProcess = (function (_EventEmitter) {
  _inherits(SubProcess, _EventEmitter);

  function SubProcess(cmd) {
    var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, SubProcess);

    _get(Object.getPrototypeOf(SubProcess.prototype), 'constructor', this).call(this);
    if (!cmd) throw new Error('Command is required'); // eslint-disable-line curly
    if (!_lodash2['default'].isString(cmd)) throw new Error('Command must be a string'); // eslint-disable-line curly
    if (!_lodash2['default'].isArray(args)) throw new Error('Args must be an array'); // eslint-disable-line curly

    this.cmd = cmd;
    this.args = args;
    this.proc = null;
    this.opts = opts;
    this.expectingExit = false;

    // get a quoted representation of the command for error strings
    this.rep = (0, _shellQuote.quote)([cmd].concat(_toConsumableArray(args)));
  }

  _createClass(SubProcess, [{
    key: 'emitLines',
    value: function emitLines(stream, lines) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _getIterator(lines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;

          this.emit('stream-line', '[' + stream.toUpperCase() + '] ' + line);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    // spawn the subprocess and return control whenever we deem that it has fully
    // "started"
  }, {
    key: 'start',
    value: function start() {
      var startDetector = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
      var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var startDelay;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            startDelay = 10;

            // the default start detector simply returns true when we get any output
            if (startDetector === null) {
              startDetector = function (stdout, stderr) {
                return stdout || stderr;
              };
            }

            // if the user passes a number, then we simply delay a certain amount of
            // time before returning control, rather than waiting for a condition
            if (_lodash2['default'].isNumber(startDetector)) {
              startDelay = startDetector;
              startDetector = null;
            }

            // return a promise so we can wrap the async behavior
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              // actually spawn the subproc
              _this.proc = (0, _child_process.spawn)(_this.cmd, _this.args, _this.opts);

              if (_this.proc.stdout) {
                _this.proc.stdout.setEncoding(_this.opts.encoding || 'utf8');
              }
              if (_this.proc.stderr) {
                _this.proc.stderr.setEncoding(_this.opts.encoding || 'utf8');
              }
              _this.lastLinePortion = { stdout: '', stderr: '' };

              // this function handles output that we collect from the subproc
              var handleOutput = function handleOutput(data) {
                // if we have a startDetector, run it on the output so we can resolve/
                // reject and move on from start
                try {
                  if (startDetector && startDetector(data.stdout, data.stderr)) {
                    startDetector = null;
                    resolve();
                  }
                } catch (e) {
                  reject(e);
                }

                // emit the actual output for whomever's listening
                _this.emit('output', data.stdout, data.stderr);

                // we also want to emit lines, but it's more complex since output
                // comes in chunks and a line could come in two different chunks, so
                // we have logic to handle that case (using this.lastLinePortion to
                // remember a line that started but did not finish in the last chunk)
                var _arr = ['stdout', 'stderr'];
                for (var _i = 0; _i < _arr.length; _i++) {
                  var stream = _arr[_i];
                  if (!data[stream]) continue; // eslint-disable-line curly
                  var lines = data[stream].split("\n");
                  if (lines.length > 1) {
                    var retLines = lines.slice(0, -1);
                    retLines[0] = _this.lastLinePortion[stream] + retLines[0];
                    _this.lastLinePortion[stream] = lines[lines.length - 1];
                    _this.emit('lines-' + stream, retLines);
                    _this.emitLines(stream, retLines);
                  } else {
                    _this.lastLinePortion[stream] += lines[0];
                  }
                }
              };

              // if we get an error spawning the proc, reject and clean up the proc
              _this.proc.on('error', function (err) {
                _this.proc.removeAllListeners('exit');
                _this.proc.kill('SIGINT');

                if (err.errno === 'ENOENT') {
                  err = new Error('Command \'' + _this.cmd + '\' not found. Is it installed?');
                }
                reject(err);
              });

              if (_this.proc.stdout) {
                _this.proc.stdout.pipe((0, _through2['default'])(function (stdout) {
                  handleOutput({ stdout: stdout, stderr: '' });
                }));
              }

              if (_this.proc.stderr) {
                _this.proc.stderr.pipe((0, _through2['default'])(function (stderr) {
                  handleOutput({ stdout: '', stderr: stderr });
                }));
              }

              // when the proc exits, we might still have a buffer of lines we were
              // waiting on more chunks to complete. Go ahead and emit those, then
              // re-emit the exit so a listener can handle the possibly-unexpected exit
              _this.proc.on('exit', function (code, signal) {
                _this.handleLastLines();

                _this.emit('exit', code, signal);

                // in addition to the bare exit event, also emit one of three other
                // events that contain more helpful information:
                // 'stop': we stopped this
                // 'die': the process ended out of our control with a non-zero exit
                // 'end': the process ended out of our control with a zero exit
                var event = _this.expectingExit ? 'stop' : 'die';
                if (!_this.expectingExit && code === 0) {
                  event = 'end';
                }
                _this.emit(event, code, signal);

                // finally clean up the proc and make sure to reset our exit
                // expectations
                _this.proc = null;
                _this.expectingExit = false;
              });

              // if the user hasn't given us a startDetector, instead just resolve
              // when startDelay ms have passed
              if (!startDetector) {
                setTimeout(function () {
                  resolve();
                }, startDelay);
              }

              // if the user has given us a timeout, start the clock for rejecting
              // the promise if we take too long to start
              if (_lodash2['default'].isNumber(timeoutMs)) {
                setTimeout(function () {
                  reject(new Error('The process did not start within ' + timeoutMs + 'ms ' + ('(cmd: \'' + _this.rep + '\')')));
                }, timeoutMs);
              }
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'handleLastLines',
    value: function handleLastLines() {
      var _arr2 = ['stdout', 'stderr'];

      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
        var stream = _arr2[_i2];
        if (this.lastLinePortion[stream]) {
          var lastLines = [this.lastLinePortion[stream]];
          this.emit('lines-' + stream, lastLines);
          this.emitLines(stream, lastLines);
          this.lastLinePortion[stream] = '';
        }
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var signal = arguments.length <= 0 || arguments[0] === undefined ? 'SIGTERM' : arguments[0];
      var timeout = arguments.length <= 1 || arguments[1] === undefined ? 10000 : arguments[1];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isRunning) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Can\'t stop process; it\'s not currently running (cmd: \'' + this.rep + '\')');

          case 2:
            // make sure to emit any data in our lines buffer whenever we're done with
            // the proc
            this.handleLastLines();
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              _this2.proc.on('close', resolve);
              _this2.expectingExit = true;
              _this2.proc.kill(signal);
              setTimeout(function () {
                reject(new Error('Process didn\'t end after ' + timeout + 'ms (cmd: \'' + _this2.rep + '\')'));
              }, timeout);
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'join',
    value: function join() {
      var allowedExitCodes = arguments.length <= 0 || arguments[0] === undefined ? [0] : arguments[0];
      return _regeneratorRuntime.async(function join$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.isRunning) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Cannot join process; it is not currently running (cmd: \'' + this.rep + '\')');

          case 2:
            return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
              _this3.proc.on('exit', function (code) {
                if (allowedExitCodes.indexOf(code) === -1) {
                  reject(new Error('Process ended with exitcode ' + code + ' (cmd: \'' + _this3.rep + '\')'));
                } else {
                  resolve(code);
                }
              });
            }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'isRunning',
    get: function get() {
      // presence of `proc` means we have connected and started
      return !!this.proc;
    }
  }]);

  return SubProcess;
})(EventEmitter);

exports.SubProcess = SubProcess;
exports['default'] = SubProcess;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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Q0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDZjtlQUNGLENBQUMsQ0FBQzthQUNKLENBQUM7Ozs7Ozs7S0FDSDs7O1NBekxhLGVBQUc7O0FBRWYsYUFBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztLQUNwQjs7O1NBcEJHLFVBQVU7R0FBUyxZQUFZOztRQTZNNUIsVUFBVSxHQUFWLFVBQVU7cUJBQ0osVUFBVSIsImZpbGUiOiJsaWIvc3VicHJvY2Vzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHByb21pc2UvcHJlZmVyLWF3YWl0LXRvLWNhbGxiYWNrcyAqL1xuXG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IHRocm91Z2ggZnJvbSAndGhyb3VnaCc7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gZXZlbnRzO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgcXVvdGUgfSBmcm9tICdzaGVsbC1xdW90ZSc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuXG5cbmNsYXNzIFN1YlByb2Nlc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoY21kLCBhcmdzID0gW10sIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFjbWQpIHRocm93IG5ldyBFcnJvcignQ29tbWFuZCBpcyByZXF1aXJlZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGN1cmx5XG4gICAgaWYgKCFfLmlzU3RyaW5nKGNtZCkpIHRocm93IG5ldyBFcnJvcignQ29tbWFuZCBtdXN0IGJlIGEgc3RyaW5nJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY3VybHlcbiAgICBpZiAoIV8uaXNBcnJheShhcmdzKSkgdGhyb3cgbmV3IEVycm9yKCdBcmdzIG11c3QgYmUgYW4gYXJyYXknKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuXG4gICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5leHBlY3RpbmdFeGl0ID0gZmFsc2U7XG5cbiAgICAvLyBnZXQgYSBxdW90ZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbW1hbmQgZm9yIGVycm9yIHN0cmluZ3NcbiAgICB0aGlzLnJlcCA9IHF1b3RlKFtjbWQsIC4uLmFyZ3NdKTtcbiAgfVxuXG4gIGdldCBpc1J1bm5pbmcgKCkge1xuICAgIC8vIHByZXNlbmNlIG9mIGBwcm9jYCBtZWFucyB3ZSBoYXZlIGNvbm5lY3RlZCBhbmQgc3RhcnRlZFxuICAgIHJldHVybiAhIXRoaXMucHJvYztcbiAgfVxuXG4gIGVtaXRMaW5lcyAoc3RyZWFtLCBsaW5lcykge1xuICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIHRoaXMuZW1pdCgnc3RyZWFtLWxpbmUnLCBgWyR7c3RyZWFtLnRvVXBwZXJDYXNlKCl9XSAke2xpbmV9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc3Bhd24gdGhlIHN1YnByb2Nlc3MgYW5kIHJldHVybiBjb250cm9sIHdoZW5ldmVyIHdlIGRlZW0gdGhhdCBpdCBoYXMgZnVsbHlcbiAgLy8gXCJzdGFydGVkXCJcbiAgYXN5bmMgc3RhcnQgKHN0YXJ0RGV0ZWN0b3IgPSBudWxsLCB0aW1lb3V0TXMgPSBudWxsKSB7XG4gICAgbGV0IHN0YXJ0RGVsYXkgPSAxMDtcblxuICAgIC8vIHRoZSBkZWZhdWx0IHN0YXJ0IGRldGVjdG9yIHNpbXBseSByZXR1cm5zIHRydWUgd2hlbiB3ZSBnZXQgYW55IG91dHB1dFxuICAgIGlmIChzdGFydERldGVjdG9yID09PSBudWxsKSB7XG4gICAgICBzdGFydERldGVjdG9yID0gKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdGRvdXQgfHwgc3RkZXJyO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgdXNlciBwYXNzZXMgYSBudW1iZXIsIHRoZW4gd2Ugc2ltcGx5IGRlbGF5IGEgY2VydGFpbiBhbW91bnQgb2ZcbiAgICAvLyB0aW1lIGJlZm9yZSByZXR1cm5pbmcgY29udHJvbCwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgYSBjb25kaXRpb25cbiAgICBpZiAoXy5pc051bWJlcihzdGFydERldGVjdG9yKSkge1xuICAgICAgc3RhcnREZWxheSA9IHN0YXJ0RGV0ZWN0b3I7XG4gICAgICBzdGFydERldGVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYSBwcm9taXNlIHNvIHdlIGNhbiB3cmFwIHRoZSBhc3luYyBiZWhhdmlvclxuICAgIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBhY3R1YWxseSBzcGF3biB0aGUgc3VicHJvY1xuICAgICAgdGhpcy5wcm9jID0gc3Bhd24odGhpcy5jbWQsIHRoaXMuYXJncywgdGhpcy5vcHRzKTtcblxuICAgICAgaWYgKHRoaXMucHJvYy5zdGRvdXQpIHtcbiAgICAgICAgdGhpcy5wcm9jLnN0ZG91dC5zZXRFbmNvZGluZyh0aGlzLm9wdHMuZW5jb2RpbmcgfHwgJ3V0ZjgnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb2Muc3RkZXJyKSB7XG4gICAgICAgIHRoaXMucHJvYy5zdGRlcnIuc2V0RW5jb2RpbmcodGhpcy5vcHRzLmVuY29kaW5nIHx8ICd1dGY4Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RMaW5lUG9ydGlvbiA9IHtzdGRvdXQ6ICcnLCBzdGRlcnI6ICcnfTtcblxuICAgICAgLy8gdGhpcyBmdW5jdGlvbiBoYW5kbGVzIG91dHB1dCB0aGF0IHdlIGNvbGxlY3QgZnJvbSB0aGUgc3VicHJvY1xuICAgICAgY29uc3QgaGFuZGxlT3V0cHV0ID0gKGRhdGEpID0+IHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIHN0YXJ0RGV0ZWN0b3IsIHJ1biBpdCBvbiB0aGUgb3V0cHV0IHNvIHdlIGNhbiByZXNvbHZlL1xuICAgICAgICAvLyByZWplY3QgYW5kIG1vdmUgb24gZnJvbSBzdGFydFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdGFydERldGVjdG9yICYmIHN0YXJ0RGV0ZWN0b3IoZGF0YS5zdGRvdXQsIGRhdGEuc3RkZXJyKSkge1xuICAgICAgICAgICAgc3RhcnREZXRlY3RvciA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgYWN0dWFsIG91dHB1dCBmb3Igd2hvbWV2ZXIncyBsaXN0ZW5pbmdcbiAgICAgICAgdGhpcy5lbWl0KCdvdXRwdXQnLCBkYXRhLnN0ZG91dCwgZGF0YS5zdGRlcnIpO1xuXG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byBlbWl0IGxpbmVzLCBidXQgaXQncyBtb3JlIGNvbXBsZXggc2luY2Ugb3V0cHV0XG4gICAgICAgIC8vIGNvbWVzIGluIGNodW5rcyBhbmQgYSBsaW5lIGNvdWxkIGNvbWUgaW4gdHdvIGRpZmZlcmVudCBjaHVua3MsIHNvXG4gICAgICAgIC8vIHdlIGhhdmUgbG9naWMgdG8gaGFuZGxlIHRoYXQgY2FzZSAodXNpbmcgdGhpcy5sYXN0TGluZVBvcnRpb24gdG9cbiAgICAgICAgLy8gcmVtZW1iZXIgYSBsaW5lIHRoYXQgc3RhcnRlZCBidXQgZGlkIG5vdCBmaW5pc2ggaW4gdGhlIGxhc3QgY2h1bmspXG4gICAgICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgICAgIGlmICghZGF0YVtzdHJlYW1dKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuICAgICAgICAgIGxldCBsaW5lcyA9IGRhdGFbc3RyZWFtXS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IHJldExpbmVzID0gbGluZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgcmV0TGluZXNbMF0gPSB0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dICsgcmV0TGluZXNbMF07XG4gICAgICAgICAgICB0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB0aGlzLmVtaXQoYGxpbmVzLSR7c3RyZWFtfWAsIHJldExpbmVzKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdExpbmVzKHN0cmVhbSwgcmV0TGluZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dICs9IGxpbmVzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gaWYgd2UgZ2V0IGFuIGVycm9yIHNwYXduaW5nIHRoZSBwcm9jLCByZWplY3QgYW5kIGNsZWFuIHVwIHRoZSBwcm9jXG4gICAgICB0aGlzLnByb2Mub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgdGhpcy5wcm9jLnJlbW92ZUFsbExpc3RlbmVycygnZXhpdCcpO1xuICAgICAgICB0aGlzLnByb2Mua2lsbCgnU0lHSU5UJyk7XG5cbiAgICAgICAgaWYgKGVyci5lcnJubyA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYENvbW1hbmQgJyR7dGhpcy5jbWR9JyBub3QgZm91bmQuIElzIGl0IGluc3RhbGxlZD9gKTtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5wcm9jLnN0ZG91dCkge1xuICAgICAgICB0aGlzLnByb2Muc3Rkb3V0LnBpcGUodGhyb3VnaChzdGRvdXQgPT4ge1xuICAgICAgICAgIGhhbmRsZU91dHB1dCh7c3Rkb3V0LCBzdGRlcnI6ICcnfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvYy5zdGRlcnIpIHtcbiAgICAgICAgdGhpcy5wcm9jLnN0ZGVyci5waXBlKHRocm91Z2goc3RkZXJyID0+IHtcbiAgICAgICAgICBoYW5kbGVPdXRwdXQoe3N0ZG91dDogJycsIHN0ZGVycn0pO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gdGhlIHByb2MgZXhpdHMsIHdlIG1pZ2h0IHN0aWxsIGhhdmUgYSBidWZmZXIgb2YgbGluZXMgd2Ugd2VyZVxuICAgICAgLy8gd2FpdGluZyBvbiBtb3JlIGNodW5rcyB0byBjb21wbGV0ZS4gR28gYWhlYWQgYW5kIGVtaXQgdGhvc2UsIHRoZW5cbiAgICAgIC8vIHJlLWVtaXQgdGhlIGV4aXQgc28gYSBsaXN0ZW5lciBjYW4gaGFuZGxlIHRoZSBwb3NzaWJseS11bmV4cGVjdGVkIGV4aXRcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVMYXN0TGluZXMoKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2V4aXQnLCBjb2RlLCBzaWduYWwpO1xuXG4gICAgICAgIC8vIGluIGFkZGl0aW9uIHRvIHRoZSBiYXJlIGV4aXQgZXZlbnQsIGFsc28gZW1pdCBvbmUgb2YgdGhyZWUgb3RoZXJcbiAgICAgICAgLy8gZXZlbnRzIHRoYXQgY29udGFpbiBtb3JlIGhlbHBmdWwgaW5mb3JtYXRpb246XG4gICAgICAgIC8vICdzdG9wJzogd2Ugc3RvcHBlZCB0aGlzXG4gICAgICAgIC8vICdkaWUnOiB0aGUgcHJvY2VzcyBlbmRlZCBvdXQgb2Ygb3VyIGNvbnRyb2wgd2l0aCBhIG5vbi16ZXJvIGV4aXRcbiAgICAgICAgLy8gJ2VuZCc6IHRoZSBwcm9jZXNzIGVuZGVkIG91dCBvZiBvdXIgY29udHJvbCB3aXRoIGEgemVybyBleGl0XG4gICAgICAgIGxldCBldmVudCA9IHRoaXMuZXhwZWN0aW5nRXhpdCA/ICdzdG9wJyA6ICdkaWUnO1xuICAgICAgICBpZiAoIXRoaXMuZXhwZWN0aW5nRXhpdCAmJiBjb2RlID09PSAwKSB7XG4gICAgICAgICAgZXZlbnQgPSAnZW5kJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXZlbnQsIGNvZGUsIHNpZ25hbCk7XG5cbiAgICAgICAgLy8gZmluYWxseSBjbGVhbiB1cCB0aGUgcHJvYyBhbmQgbWFrZSBzdXJlIHRvIHJlc2V0IG91ciBleGl0XG4gICAgICAgIC8vIGV4cGVjdGF0aW9uc1xuICAgICAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cGVjdGluZ0V4aXQgPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiB0aGUgdXNlciBoYXNuJ3QgZ2l2ZW4gdXMgYSBzdGFydERldGVjdG9yLCBpbnN0ZWFkIGp1c3QgcmVzb2x2ZVxuICAgICAgLy8gd2hlbiBzdGFydERlbGF5IG1zIGhhdmUgcGFzc2VkXG4gICAgICBpZiAoIXN0YXJ0RGV0ZWN0b3IpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHJlc29sdmUoKTsgfSwgc3RhcnREZWxheSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSB1c2VyIGhhcyBnaXZlbiB1cyBhIHRpbWVvdXQsIHN0YXJ0IHRoZSBjbG9jayBmb3IgcmVqZWN0aW5nXG4gICAgICAvLyB0aGUgcHJvbWlzZSBpZiB3ZSB0YWtlIHRvbyBsb25nIHRvIHN0YXJ0XG4gICAgICBpZiAoXy5pc051bWJlcih0aW1lb3V0TXMpKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRoZSBwcm9jZXNzIGRpZCBub3Qgc3RhcnQgd2l0aGluICR7dGltZW91dE1zfW1zIGAgK1xuICAgICAgICAgICAgYChjbWQ6ICcke3RoaXMucmVwfScpYCkpO1xuICAgICAgICB9LCB0aW1lb3V0TXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlTGFzdExpbmVzICgpIHtcbiAgICBmb3IgKGxldCBzdHJlYW0gb2YgWydzdGRvdXQnLCAnc3RkZXJyJ10pIHtcbiAgICAgIGlmICh0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dKSB7XG4gICAgICAgIGNvbnN0IGxhc3RMaW5lcyA9IFt0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dXTtcbiAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCBsYXN0TGluZXMpO1xuICAgICAgICB0aGlzLmVtaXRMaW5lcyhzdHJlYW0sIGxhc3RMaW5lcyk7XG4gICAgICAgIHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0gPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzdG9wIChzaWduYWwgPSAnU0lHVEVSTScsIHRpbWVvdXQgPSAxMDAwMCkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RvcCBwcm9jZXNzOyBpdCdzIG5vdCBjdXJyZW50bHkgcnVubmluZyAoY21kOiAnJHt0aGlzLnJlcH0nKWApO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gZW1pdCBhbnkgZGF0YSBpbiBvdXIgbGluZXMgYnVmZmVyIHdoZW5ldmVyIHdlJ3JlIGRvbmUgd2l0aFxuICAgIC8vIHRoZSBwcm9jXG4gICAgdGhpcy5oYW5kbGVMYXN0TGluZXMoKTtcbiAgICByZXR1cm4gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wcm9jLm9uKCdjbG9zZScsIHJlc29sdmUpO1xuICAgICAgdGhpcy5leHBlY3RpbmdFeGl0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJvYy5raWxsKHNpZ25hbCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUHJvY2VzcyBkaWRuJ3QgZW5kIGFmdGVyICR7dGltZW91dH1tcyAoY21kOiAnJHt0aGlzLnJlcH0nKWApKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgam9pbiAoYWxsb3dlZEV4aXRDb2RlcyA9IFswXSkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGpvaW4gcHJvY2VzczsgaXQgaXMgbm90IGN1cnJlbnRseSBydW5uaW5nIChjbWQ6ICcke3RoaXMucmVwfScpYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChhbGxvd2VkRXhpdENvZGVzLmluZGV4T2YoY29kZSkgPT09IC0xKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUHJvY2VzcyBlbmRlZCB3aXRoIGV4aXRjb2RlICR7Y29kZX0gKGNtZDogJyR7dGhpcy5yZXB9JylgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgU3ViUHJvY2VzcyB9O1xuZXhwb3J0IGRlZmF1bHQgU3ViUHJvY2VzcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
