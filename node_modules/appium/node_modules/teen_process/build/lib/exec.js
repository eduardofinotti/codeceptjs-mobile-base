/* eslint-disable promise/prefer-await-to-callbacks */

'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _child_process = require('child_process');

var _shellQuote = require('shell-quote');

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

function exec(cmd) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // get a quoted representation of the command for error strings
  var rep = (0, _shellQuote.quote)([cmd].concat(_toConsumableArray(args)));

  // extend default options; we're basically re-implementing exec's options
  // for use here with spawn under the hood
  opts = _Object$assign({
    timeout: null,
    encoding: 'utf8',
    killSignal: 'SIGTERM',
    cwd: undefined,
    env: process.env,
    ignoreOutput: false,
    stdio: "inherit",
    isBuffer: false,
    shell: undefined
  }, opts);

  // this is an async function, so return a promise
  return new _bluebird2['default'](function (resolve, reject) {
    // spawn the child process with options; we don't currently expose any of
    // the other 'spawn' options through the API
    var proc = (0, _child_process.spawn)(cmd, args, { cwd: opts.cwd, env: opts.env, shell: opts.shell });
    var stdoutArr = [],
        stderrArr = [],
        timer = null;

    // if the process errors out, reject the promise
    proc.on('error', function (err) {
      var msg = 'Command \'' + rep + '\' errored out: ' + err.stack;
      if (err.errno === 'ENOENT') {
        msg = 'Command \'' + cmd + '\' not found. Is it installed?';
      }
      reject(new Error(msg));
    });
    if (proc.stdin) {
      proc.stdin.on('error', function (err) {
        reject(new Error('Standard input \'' + err.syscall + '\' error: ' + err.stack));
      });
    }
    if (proc.stdout) {
      proc.stdout.on('error', function (err) {
        reject(new Error('Standard output \'' + err.syscall + '\' error: ' + err.stack));
      });
    }
    if (proc.stderr) {
      proc.stderr.on('error', function (err) {
        reject(new Error('Standard error \'' + err.syscall + '\' error: ' + err.stack));
      });
    }

    // keep track of stdout/stderr if we haven't said not to
    if (!opts.ignoreOutput) {
      if (proc.stdout) {
        proc.stdout.on('data', function (data) {
          stdoutArr.push(data);
        });
      }
      if (proc.stderr) {
        proc.stderr.on('data', function (data) {
          stderrArr.push(data);
        });
      }
    }

    function getStdio(isBuffer) {
      var stdout = undefined,
          stderr = undefined;
      if (isBuffer) {
        stdout = Buffer.concat(stdoutArr);
        stderr = Buffer.concat(stderrArr);
      } else {
        stdout = Buffer.concat(stdoutArr).toString(opts.encoding);
        stderr = Buffer.concat(stderrArr).toString(opts.encoding);
      }
      return { stdout: stdout, stderr: stderr };
    }

    // if the process ends, either resolve or reject the promise based on the
    // exit code of the process. either way, attach stdout, stderr, and code.
    // Also clean up the timer if it exists
    proc.on('close', function (code) {
      if (timer) {
        clearTimeout(timer);
      }

      var _getStdio = getStdio(opts.isBuffer);

      var stdout = _getStdio.stdout;
      var stderr = _getStdio.stderr;

      if (code === 0) {
        resolve({ stdout: stdout, stderr: stderr, code: code });
      } else {
        var err = new Error('Command \'' + rep + '\' exited with code ' + code);
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: code });
        reject(err);
      }
    });

    // if we set a timeout on the child process, cut into the execution and
    // reject if the timeout is reached. Attach the stdout/stderr we currently
    // have in case it's helpful in debugging
    if (opts.timeout) {
      timer = setTimeout(function () {
        var _getStdio2 = getStdio(opts.isBuffer);

        var stdout = _getStdio2.stdout;
        var stderr = _getStdio2.stderr;

        var err = new Error('Command \'' + rep + '\' timed out after ' + opts.timeout + 'ms');
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: null });
        reject(err);
        // reject and THEN kill to avoid race conditions with the handlers
        // above
        proc.kill(opts.killSignal);
      }, opts.timeout);
    }
  });
}

exports.exec = exec;
exports['default'] = exec;
//# sourceMappingURL=data:application/json;charset=utf8;base64,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LEVBQUMsQ0FBQyxDQUFDO09BQ2pDLE1BQU07QUFDTCxZQUFJLEdBQUcsR0FBRyxJQUFJLEtBQUssZ0JBQWEsR0FBRyw0QkFBc0IsSUFBSSxDQUFHLENBQUM7QUFDakUsV0FBRyxHQUFHLGVBQWMsR0FBRyxFQUFFLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFFLElBQUksRUFBSixJQUFJLEVBQUMsQ0FBQyxDQUFDO0FBQ2pELGNBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUNiO0tBQ0YsQ0FBQyxDQUFDOzs7OztBQUtILFFBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNoQixXQUFLLEdBQUcsVUFBVSxDQUFDLFlBQU07eUJBQ0EsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7O1lBQXpDLE1BQU0sY0FBTixNQUFNO1lBQUUsTUFBTSxjQUFOLE1BQU07O0FBQ25CLFlBQUksR0FBRyxHQUFHLElBQUksS0FBSyxnQkFBYSxHQUFHLDJCQUFxQixJQUFJLENBQUMsT0FBTyxRQUFLLENBQUM7QUFDMUUsV0FBRyxHQUFHLGVBQWMsR0FBRyxFQUFFLEVBQUMsTUFBTSxFQUFOLE1BQU0sRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO0FBQ3ZELGNBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7O0FBR1osWUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7T0FDNUIsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDbEI7R0FDRixDQUFDLENBQUM7Q0FDSjs7UUFFUSxJQUFJLEdBQUosSUFBSTtxQkFDRSxJQUFJIiwiZmlsZSI6ImxpYi9leGVjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzICovXG5cbmltcG9ydCB7IHNwYXduIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBxdW90ZSB9IGZyb20gJ3NoZWxsLXF1b3RlJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcblxuXG5mdW5jdGlvbiBleGVjIChjbWQsIGFyZ3MgPSBbXSwgb3B0cyA9IHt9KSB7XG4gIC8vIGdldCBhIHF1b3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tbWFuZCBmb3IgZXJyb3Igc3RyaW5nc1xuICBjb25zdCByZXAgPSBxdW90ZShbY21kLCAuLi5hcmdzXSk7XG5cbiAgLy8gZXh0ZW5kIGRlZmF1bHQgb3B0aW9uczsgd2UncmUgYmFzaWNhbGx5IHJlLWltcGxlbWVudGluZyBleGVjJ3Mgb3B0aW9uc1xuICAvLyBmb3IgdXNlIGhlcmUgd2l0aCBzcGF3biB1bmRlciB0aGUgaG9vZFxuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgdGltZW91dDogbnVsbCxcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIGtpbGxTaWduYWw6ICdTSUdURVJNJyxcbiAgICBjd2Q6IHVuZGVmaW5lZCxcbiAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgIGlnbm9yZU91dHB1dDogZmFsc2UsXG4gICAgc3RkaW86IFwiaW5oZXJpdFwiLFxuICAgIGlzQnVmZmVyOiBmYWxzZSxcbiAgICBzaGVsbDogdW5kZWZpbmVkLFxuICB9LCBvcHRzKTtcblxuICAvLyB0aGlzIGlzIGFuIGFzeW5jIGZ1bmN0aW9uLCBzbyByZXR1cm4gYSBwcm9taXNlXG4gIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gc3Bhd24gdGhlIGNoaWxkIHByb2Nlc3Mgd2l0aCBvcHRpb25zOyB3ZSBkb24ndCBjdXJyZW50bHkgZXhwb3NlIGFueSBvZlxuICAgIC8vIHRoZSBvdGhlciAnc3Bhd24nIG9wdGlvbnMgdGhyb3VnaCB0aGUgQVBJXG4gICAgbGV0IHByb2MgPSBzcGF3bihjbWQsIGFyZ3MsIHtjd2Q6IG9wdHMuY3dkLCBlbnY6IG9wdHMuZW52LCBzaGVsbDogb3B0cy5zaGVsbH0pO1xuICAgIGxldCBzdGRvdXRBcnIgPSBbXSwgc3RkZXJyQXJyID0gW10sIHRpbWVyID0gbnVsbDtcblxuICAgIC8vIGlmIHRoZSBwcm9jZXNzIGVycm9ycyBvdXQsIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgIHByb2Mub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgbGV0IG1zZyA9IGBDb21tYW5kICcke3JlcH0nIGVycm9yZWQgb3V0OiAke2Vyci5zdGFja31gO1xuICAgICAgaWYgKGVyci5lcnJubyA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgbXNnID0gYENvbW1hbmQgJyR7Y21kfScgbm90IGZvdW5kLiBJcyBpdCBpbnN0YWxsZWQ/YDtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgfSk7XG4gICAgaWYgKHByb2Muc3RkaW4pIHtcbiAgICAgIHByb2Muc3RkaW4ub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBTdGFuZGFyZCBpbnB1dCAnJHtlcnIuc3lzY2FsbH0nIGVycm9yOiAke2Vyci5zdGFja31gKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb2Muc3Rkb3V0KSB7XG4gICAgICBwcm9jLnN0ZG91dC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFN0YW5kYXJkIG91dHB1dCAnJHtlcnIuc3lzY2FsbH0nIGVycm9yOiAke2Vyci5zdGFja31gKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByb2Muc3RkZXJyKSB7XG4gICAgICBwcm9jLnN0ZGVyci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFN0YW5kYXJkIGVycm9yICcke2Vyci5zeXNjYWxsfScgZXJyb3I6ICR7ZXJyLnN0YWNrfWApKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygc3Rkb3V0L3N0ZGVyciBpZiB3ZSBoYXZlbid0IHNhaWQgbm90IHRvXG4gICAgaWYgKCFvcHRzLmlnbm9yZU91dHB1dCkge1xuICAgICAgaWYgKHByb2Muc3Rkb3V0KSB7XG4gICAgICAgIHByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBzdGRvdXRBcnIucHVzaChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvYy5zdGRlcnIpIHtcbiAgICAgICAgcHJvYy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIHN0ZGVyckFyci5wdXNoKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGRpbyAoaXNCdWZmZXIpIHtcbiAgICAgIGxldCBzdGRvdXQsIHN0ZGVycjtcbiAgICAgIGlmIChpc0J1ZmZlcikge1xuICAgICAgICBzdGRvdXQgPSBCdWZmZXIuY29uY2F0KHN0ZG91dEFycik7XG4gICAgICAgIHN0ZGVyciA9IEJ1ZmZlci5jb25jYXQoc3RkZXJyQXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZG91dCA9IEJ1ZmZlci5jb25jYXQoc3Rkb3V0QXJyKS50b1N0cmluZyhvcHRzLmVuY29kaW5nKTtcbiAgICAgICAgc3RkZXJyID0gQnVmZmVyLmNvbmNhdChzdGRlcnJBcnIpLnRvU3RyaW5nKG9wdHMuZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtzdGRvdXQsIHN0ZGVycn07XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHByb2Nlc3MgZW5kcywgZWl0aGVyIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBwcm9taXNlIGJhc2VkIG9uIHRoZVxuICAgIC8vIGV4aXQgY29kZSBvZiB0aGUgcHJvY2Vzcy4gZWl0aGVyIHdheSwgYXR0YWNoIHN0ZG91dCwgc3RkZXJyLCBhbmQgY29kZS5cbiAgICAvLyBBbHNvIGNsZWFuIHVwIHRoZSB0aW1lciBpZiBpdCBleGlzdHNcbiAgICBwcm9jLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGxldCB7c3Rkb3V0LCBzdGRlcnJ9ID0gZ2V0U3RkaW8ob3B0cy5pc0J1ZmZlcik7XG4gICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHtzdGRvdXQsIHN0ZGVyciwgY29kZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcihgQ29tbWFuZCAnJHtyZXB9JyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcbiAgICAgICAgZXJyID0gT2JqZWN0LmFzc2lnbihlcnIsIHtzdGRvdXQsIHN0ZGVyciwgY29kZX0pO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHdlIHNldCBhIHRpbWVvdXQgb24gdGhlIGNoaWxkIHByb2Nlc3MsIGN1dCBpbnRvIHRoZSBleGVjdXRpb24gYW5kXG4gICAgLy8gcmVqZWN0IGlmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuIEF0dGFjaCB0aGUgc3Rkb3V0L3N0ZGVyciB3ZSBjdXJyZW50bHlcbiAgICAvLyBoYXZlIGluIGNhc2UgaXQncyBoZWxwZnVsIGluIGRlYnVnZ2luZ1xuICAgIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCB7c3Rkb3V0LCBzdGRlcnJ9ID0gZ2V0U3RkaW8ob3B0cy5pc0J1ZmZlcik7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYENvbW1hbmQgJyR7cmVwfScgdGltZWQgb3V0IGFmdGVyICR7b3B0cy50aW1lb3V0fW1zYCk7XG4gICAgICAgIGVyciA9IE9iamVjdC5hc3NpZ24oZXJyLCB7c3Rkb3V0LCBzdGRlcnIsIGNvZGU6IG51bGx9KTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIC8vIHJlamVjdCBhbmQgVEhFTiBraWxsIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyB3aXRoIHRoZSBoYW5kbGVyc1xuICAgICAgICAvLyBhYm92ZVxuICAgICAgICBwcm9jLmtpbGwob3B0cy5raWxsU2lnbmFsKTtcbiAgICAgIH0sIG9wdHMudGltZW91dCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgZXhlYyB9O1xuZXhwb3J0IGRlZmF1bHQgZXhlYztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
